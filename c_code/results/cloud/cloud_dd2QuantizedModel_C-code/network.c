/* AUTOGENERATED DO NOT MODIFY */

/**
  ******************************************************************************
  * @file    network.c
  * @brief   NN Code autogenerated DO NOT MODIFY IT
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/*
 * GIT_SHA         "e619e8606099384540d70eeaaa8091752b1bebe9"
 * GIT_BRANCH      "STAI-2.2"
 * GIT_DESCRIPTION "atonn-v1.1.1-14-ge619e860"
 *
 * Command Line options:
 * --load-mdesc-file = "/app/stm32ai/Utilities/configs/stm32n6"
 * --load-mpool-file = "/app/stm32ai/Utilities/linux/targets/stm32/resources/mpools/stm32n6"
 * --cache-maintenance = true
 * --enable-virtual-mem-pools = true
 * --native-float = true
 * --json-quant-file = "/tmp/stm32ai_service/fc5e237b-c515-4a26-ad52-e12acf56fb6b/output/quantized_model_OE_3_3_0_Q.json"
 * --optimization = 3
 * --Os = true
 * --Omax-ca-pipe = 4
 * --Ocache-opt = true
 * --enable-epoch-controller = true
 * --output-info-file = "c_info"
 * --onnx-input = "/tmp/stm32ai_service/fc5e237b-c515-4a26-ad52-e12acf56fb6b/output/quantized_model_OE_3_3_0.onnx"
 * --out-dir-prefix = "/tmp/stm32ai_service/fc5e237b-c515-4a26-ad52-e12acf56fb6b/workspace/neural_art__network/"
 * --mvei = true
 * --Oauto-sched = true
 * --Oshuffle-dma = true
 *
 * auto* option expanded into:
 *   alt-scheduler = true
 */

#include "ll_aton_NN_interface.h"
#include "ll_aton.h"
#include "ll_aton_lib.h"
#include "ll_aton_version.h"
#include "ll_sw.h"
#include "ecloader.h"

#if LL_ATON_VERSION_MAJOR != 1 || LL_ATON_VERSION_MINOR != 1 || LL_ATON_VERSION_MICRO != 1 || LL_ATON_VERSION_DEV != 14
#  error "Possible mismatch in ll_aton library used"
#endif

#if !defined(LL_ATON_DBG_BUFFER_INFO_EXCLUDED)
#  define LL_ATON_DBG_BUFFER_INFO_EXCLUDED 0
#endif

/* global pool 7 is ? */
/* index=7 file postfix=xSPI1 name=hyperRAM offset=0x90000000  absolute_mode size=33554424 READ_WRITE THROUGHPUT=MID LATENCY=HIGH byte width=2 freq ratio=5 burst max length=MAXINT burst penalty=0 pipelined=ON cacheable=ON read_power=380 write_power=340 use4initializers=YES score=82  */
/* global pool 8 is 4.36 MB */
/* index=8 file postfix=xSPI2 name=octoFlash offset=0x71000000  absolute_mode size=117440504 READ_ONLY THROUGHPUT=MID LATENCY=HIGH byte width=1 freq ratio=6 burst max length=MAXINT burst penalty=0 pipelined=ON cacheable=ON read_power=110 write_power=400 use4initializers=YES score=50  */
/* global pool 1 is 64.69 KB */
/* index=1 file postfix=AXISRAM5 name=npuRAM5 offset=0x342e0000  absolute_mode size=458752 READ_WRITE THROUGHPUT=HIGH LATENCY=LOW byte width=8 freq ratio=1.25 burst max length=MAXINT burst penalty=0 pipelined=ON cacheable=OFF read_power=18.531 write_power=16.201 use4initializers=NO score=94  */
/* global pool 2 is ? */
/* index=2 file postfix=AXISRAM4 name=npuRAM4 offset=0x34270000  absolute_mode size=458752 READ_WRITE THROUGHPUT=HIGH LATENCY=LOW byte width=8 freq ratio=1.25 burst max length=MAXINT burst penalty=0 pipelined=ON cacheable=OFF read_power=18.531 write_power=16.201 use4initializers=NO score=94  */
/* global pool 3 is 147.88 KB */
/* index=3 file postfix=AXISRAM3 name=npuRAM3 offset=0x34200000  absolute_mode size=458752 READ_WRITE THROUGHPUT=HIGH LATENCY=LOW byte width=8 freq ratio=1.25 burst max length=MAXINT burst penalty=0 pipelined=ON cacheable=OFF read_power=18.531 write_power=16.201 use4initializers=NO score=94  */
/* global pool 0 is ? */
/* index=0 file postfix=AXISRAM6 name=npuRAM6 offset=0x34350000  absolute_mode size=458744 READ_WRITE THROUGHPUT=HIGH LATENCY=LOW byte width=8 freq ratio=1.25 burst max length=MAXINT burst penalty=0 pipelined=ON cacheable=OFF read_power=19.006 write_power=15.79 use4initializers=NO score=94  */
/* global pool 11 is 1.94 MB */
/* index=11 file postfix=AXISRAM2_AXISRAM3_AXISRAM4_AXISRAM5_AXISRAM6 name=cpuRAM2_npuRAM3_npuRAM4_npuRAM5_npuRAM6 offset=0x34100000  absolute_mode size=2883576 vpool READ_WRITE THROUGHPUT=MID LATENCY=MID byte width=8 freq ratio=2.5 burst max length=MAXINT burst penalty=0 pipelined=ON cacheable=OFF read_power=19.006 write_power=16.201 use4initializers=NO score=85  */
/* global pool 4 is 1.00 MB */
/* index=4 file postfix=AXISRAM2 name=cpuRAM2 offset=0x34100000  absolute_mode size=1048576 READ_WRITE THROUGHPUT=MID LATENCY=MID byte width=8 freq ratio=2.5 burst max length=MAXINT burst penalty=0 pipelined=ON cacheable=OFF read_power=17.324 write_power=15.321 use4initializers=NO score=84  */
/* global pool 5 is ? */
/* index=5 file postfix=AXISRAM1 name=cpuRAM1 offset=0x34064000  absolute_mode size=0 READ_WRITE THROUGHPUT=MID LATENCY=MID byte width=8 freq ratio=2.5 burst max length=MAXINT burst penalty=0 pipelined=ON cacheable=OFF read_power=16.616 write_power=14.522 use4initializers=NO score=84  */
/* global pool 6 is ? */
/* index=6 file postfix=AXIFLEXMEM name=flexMEM offset=0x34000000  absolute_mode size=0 READ_WRITE THROUGHPUT=MID LATENCY=MID byte width=8 freq ratio=2.5 burst max length=MAXINT burst penalty=0 pipelined=ON cacheable=OFF read_power=9.381 write_power=8.569 use4initializers=NO score=84  */

LL_ATON_User_IO_Result_t LL_ATON_Set_User_Input_Buffer_Default(uint32_t num, void* buffer, uint32_t size)
{
  { 
    return LL_ATON_User_IO_WRONG_INDEX;
  }
}

void *LL_ATON_Get_User_Input_Buffer_Default(uint32_t num)
{
  { 
    return NULL;
  }
}

LL_ATON_User_IO_Result_t LL_ATON_Set_User_Output_Buffer_Default(uint32_t num, void* buffer, uint32_t size)
{
  { 
    return LL_ATON_User_IO_WRONG_INDEX;
  }
}

void *LL_ATON_Get_User_Output_Buffer_Default(uint32_t num)
{
  { 
    return NULL;
  }
}

#include "network_ecblobs.h"

/* scheduling epoch=0    nodes=823 ------------------------------------------------------------------- */

// Epoch Controller Blob (name='_ec_blob_Default_1') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_1') start function
static void _ec_blob_cache_start_func_1(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 3840);

};


/* scheduling epoch=7    nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_7(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_84 */
  static const uint32_t Transpose_84_tensor_shape_in_7_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_84_tensor_shape_in_7[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 7680,
      .offset_end = 11520,
      .offset_limit = 11584,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_84_tensor_shape_in_7_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_84_tensor_axes_offsets_in_7_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_84_tensor_axes_offsets_in_7[] = {
    Transpose_84_tensor_axes_offsets_in_7_0
  };

  static const uint32_t Transpose_84_tensor_shape_out_7_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_84_tensor_shape_out_7[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 11520,
      .offset_end = 15360,
      .offset_limit = 15424,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_84_tensor_shape_out_7_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_84_tensor_axes_offsets_out_7_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_84_tensor_axes_offsets_out_7[] = {
    Transpose_84_tensor_axes_offsets_out_7_0
  };

  static const uint8_t Transpose_84_perm_to_use_array_in_7[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_84_target_pos_array_in_7[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_84_tensor_shape_in_7[0], Transpose_84_tensor_axes_offsets_in_7[0], &Transpose_84_tensor_shape_out_7[0], Transpose_84_tensor_axes_offsets_out_7[0], Transpose_84_target_pos_array_in_7, Transpose_84_perm_to_use_array_in_7, 6, 7);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_8') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_8') start function
static void _ec_blob_cache_start_func_8(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 3840);

};


/* scheduling epoch=9    nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_9(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_92 */
  static const uint32_t Transpose_92_tensor_shape_in_9_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_92_tensor_shape_in_9[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 7680,
      .offset_end = 11520,
      .offset_limit = 11584,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_92_tensor_shape_in_9_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_92_tensor_axes_offsets_in_9_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_92_tensor_axes_offsets_in_9[] = {
    Transpose_92_tensor_axes_offsets_in_9_0
  };

  static const uint32_t Transpose_92_tensor_shape_out_9_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_92_tensor_shape_out_9[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 0,
      .offset_end = 3840,
      .offset_limit = 3904,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_92_tensor_shape_out_9_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_92_tensor_axes_offsets_out_9_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_92_tensor_axes_offsets_out_9[] = {
    Transpose_92_tensor_axes_offsets_out_9_0
  };

  static const uint8_t Transpose_92_perm_to_use_array_in_9[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_92_target_pos_array_in_9[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_92_tensor_shape_in_9[0], Transpose_92_tensor_axes_offsets_in_9[0], &Transpose_92_tensor_shape_out_9[0], Transpose_92_tensor_axes_offsets_out_9[0], Transpose_92_target_pos_array_in_9, Transpose_92_perm_to_use_array_in_9, 2, 3);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_10') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_10') start function
static void _ec_blob_cache_start_func_10(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) /* Equivalent hex address = 0x342e0f00UL */, 7680);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */, 3840);

};


/* scheduling epoch=13   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_13(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15296))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15328))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15296))) /* Equivalent hex address = 0x342e3bc0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_102_gemm_19_3_conv_334 */
  Conv_integer_sw_info conv_integer1_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 6720))) /* Equivalent hex address = 0x342e1a40UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4563616))) /* Equivalent hex address = 0x7145a2a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568544))) /* Equivalent hex address = 0x7145b5e0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572768))) /* Equivalent hex address = 0x7145c660UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568560))) /* Equivalent hex address = 0x7145b5f0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572784))) /* Equivalent hex address = 0x7145c670UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568576))) /* Equivalent hex address = 0x7145b600UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572800))) /* Equivalent hex address = 0x7145c680UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) /* Equivalent hex address = 0x342e3840UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_102_gemm_19_3_conv_334 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer1_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15328))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) /* Equivalent hex address = 0x342e3840UL */, 928);

}


/* scheduling epoch=14   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_14(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8576))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8608))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8576))) /* Equivalent hex address = 0x342e2180UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11776))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11808))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11776))) /* Equivalent hex address = 0x342e2e00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_102_gemm_7_0_conv_313 */
  Conv_integer_sw_info conv_integer2_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) /* Equivalent hex address = 0x342e0f00UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4563360))) /* Equivalent hex address = 0x7145a1a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568448))) /* Equivalent hex address = 0x7145b580UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572672))) /* Equivalent hex address = 0x7145c600UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568464))) /* Equivalent hex address = 0x7145b590UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572688))) /* Equivalent hex address = 0x7145c610UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568480))) /* Equivalent hex address = 0x7145b5a0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572704))) /* Equivalent hex address = 0x7145c620UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11664))) /* Equivalent hex address = 0x342e2d90UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_102_gemm_7_0_conv_313 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer2_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8608))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 928);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11808))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 160);

}


/* scheduling epoch=15   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_15(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10688))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10720))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10688))) /* Equivalent hex address = 0x342e29c0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_102_gemm_15_2_conv_327 */
  Conv_integer_sw_info conv_integer3_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5760))) /* Equivalent hex address = 0x342e1680UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4563488))) /* Equivalent hex address = 0x7145a220UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568496))) /* Equivalent hex address = 0x7145b5b0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572720))) /* Equivalent hex address = 0x7145c630UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568512))) /* Equivalent hex address = 0x7145b5c0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572736))) /* Equivalent hex address = 0x7145c640UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568528))) /* Equivalent hex address = 0x7145b5d0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572752))) /* Equivalent hex address = 0x7145c650UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_102_gemm_15_2_conv_327 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer3_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 928);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10720))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */, 160);

}


/* scheduling epoch=16   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_16(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1024))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1056))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1024))) /* Equivalent hex address = 0x342e0400UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10496))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10528))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10496))) /* Equivalent hex address = 0x342e2900UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_102_gemm_11_1_conv_320 */
  Conv_integer_sw_info conv_integer4_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8640))) /* Equivalent hex address = 0x342e21c0UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4800))) /* Equivalent hex address = 0x342e12c0UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4562592))) /* Equivalent hex address = 0x71459ea0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568160))) /* Equivalent hex address = 0x7145b460UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572384))) /* Equivalent hex address = 0x7145c4e0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568176))) /* Equivalent hex address = 0x7145b470UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572400))) /* Equivalent hex address = 0x7145c4f0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568192))) /* Equivalent hex address = 0x7145b480UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572416))) /* Equivalent hex address = 0x7145c500UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 912))) /* Equivalent hex address = 0x342e0390UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_102_gemm_11_1_conv_320 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer4_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1056))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10528))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */, 928);

}


// Epoch Controller Blob (name='_ec_blob_Default_17') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_17') start function
static void _ec_blob_cache_start_func_17(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10784))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10784))) /* Equivalent hex address = 0x342e2a20UL */, 3616);

};


/* scheduling epoch=21   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_21(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3584))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3616))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3584))) /* Equivalent hex address = 0x342e0e00UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14880))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14912))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14880))) /* Equivalent hex address = 0x342e3a20UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Softmax node=Softmax_106 */
  Softmax_integer_sw_info softmax_integer5_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 4,
    .general.input.dim.num_elem = 3600,
    .general.input.stride.b = 3600,
    .general.input.stride.h = 120,
    .general.input.stride.w = 4,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10800))) /* Equivalent hex address = 0x342e2a30UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566400))) /* Equivalent hex address = 0x7145ad80UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570624))) /* Equivalent hex address = 0x7145be00UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566416))) /* Equivalent hex address = 0x7145ad90UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570640))) /* Equivalent hex address = 0x7145be10UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 125,
    .scratch.dim.tensor_c = 1,
    .scratch.dim.num_elem = 125,
    .scratch.stride.b = 500,
    .scratch.stride.h = 500,
    .scratch.stride.w = 4,
    .scratch.stride.c = 4,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) /* Equivalent hex address = 0x342e3840UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 4,
    .general.output.dim.num_elem = 3600,
    .general.output.stride.b = 3600,
    .general.output.stride.h = 120,
    .general.output.stride.w = 4,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .quantized_multiplier = 1965472128,
    .left_shift = 24,
    .diff_min = -124,
    .axis = 3,
    .general.type = LL_SW_SOFTMAX,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Softmax_106 mapped on EmbedNets (INTEGER) as Softmax | Category: Computational */
  ll_sw_forward_softmax_integer(&softmax_integer5_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3616))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 3616);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14912))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) /* Equivalent hex address = 0x342e3840UL */, 512);

}


// Epoch Controller Blob (name='_ec_blob_Default_22') micro instructions needed


/* scheduling epoch=23   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_23(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 3648);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Split node=Softmax_106_out_0_24_split_B_28 */
  static const uint32_t Softmax_106_out_0_24_split_B_28_tensor_shape_in_23_shape_0[] = { 4, 30, 30 };
  static const LL_LIB_TensorShape_TypeDef Softmax_106_out_0_24_split_B_28_tensor_shape_in_23[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 0,
      .offset_end = 3600,
      .offset_limit = 3664,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_106_out_0_24_split_B_28_tensor_shape_in_23_shape_0,
      .batch = 4,
    }
  };

  static const uint32_t Softmax_106_out_0_24_split_B_28_tensor_shape_out_23_shape_0[] = { 1, 30, 30 };
  static const uint32_t Softmax_106_out_0_24_split_B_28_tensor_shape_out_23_shape_1[] = { 1, 30, 30 };
  static const uint32_t Softmax_106_out_0_24_split_B_28_tensor_shape_out_23_shape_2[] = { 1, 30, 30 };
  static const uint32_t Softmax_106_out_0_24_split_B_28_tensor_shape_out_23_shape_3[] = { 1, 30, 30 };
  static const LL_LIB_TensorShape_TypeDef Softmax_106_out_0_24_split_B_28_tensor_shape_out_23[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 19200,
      .offset_end = 20100,
      .offset_limit = 20168,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_106_out_0_24_split_B_28_tensor_shape_out_23_shape_0,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 20112,
      .offset_end = 21012,
      .offset_limit = 21080,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_106_out_0_24_split_B_28_tensor_shape_out_23_shape_1,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 21024,
      .offset_end = 21924,
      .offset_limit = 21992,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_106_out_0_24_split_B_28_tensor_shape_out_23_shape_2,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 21936,
      .offset_end = 22836,
      .offset_limit = 22904,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_106_out_0_24_split_B_28_tensor_shape_out_23_shape_3,
      .batch = 1,
    }
  };

  LL_ATON_LIB_Split(&Softmax_106_out_0_24_split_B_28_tensor_shape_in_23[0], true, &Softmax_106_out_0_24_split_B_28_tensor_shape_out_23, 4, 3, 0, 1, 3, 5, 6);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 3648);

}


// Epoch Controller Blob (name='_ec_blob_Default_24') micro instructions needed


/* scheduling epoch=25   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_25(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22944))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22976))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22944))) /* Equivalent hex address = 0x342e59a0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_107_gemm_31_0_conv_341 */
  Conv_integer_sw_info conv_integer6_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 18240))) /* Equivalent hex address = 0x342e4740UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4560288))) /* Equivalent hex address = 0x714595a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567296))) /* Equivalent hex address = 0x7145b100UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571520))) /* Equivalent hex address = 0x7145c180UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567312))) /* Equivalent hex address = 0x7145b110UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571536))) /* Equivalent hex address = 0x7145c190UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567328))) /* Equivalent hex address = 0x7145b120UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571552))) /* Equivalent hex address = 0x7145c1a0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) /* Equivalent hex address = 0x342e5940UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_107_gemm_31_0_conv_341 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer6_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22976))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) /* Equivalent hex address = 0x342e5940UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */, 960);

}


/* scheduling epoch=26   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_26(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 18336))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 18368))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 18336))) /* Equivalent hex address = 0x342e47a0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_107_gemm_43_3_conv_362 */
  Conv_integer_sw_info conv_integer7_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 17280))) /* Equivalent hex address = 0x342e4380UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21936))) /* Equivalent hex address = 0x342e55b0UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4560544))) /* Equivalent hex address = 0x714596a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567392))) /* Equivalent hex address = 0x7145b160UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571616))) /* Equivalent hex address = 0x7145c1e0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567408))) /* Equivalent hex address = 0x7145b170UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571632))) /* Equivalent hex address = 0x7145c1f0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567424))) /* Equivalent hex address = 0x7145b180UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571648))) /* Equivalent hex address = 0x7145c200UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 18240))) /* Equivalent hex address = 0x342e4740UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) /* Equivalent hex address = 0x342e8ac0UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_107_gemm_43_3_conv_362 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer7_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 18240))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 18368))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 18240))) /* Equivalent hex address = 0x342e4740UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) /* Equivalent hex address = 0x342e8ac0UL */, 960);

}


/* scheduling epoch=27   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_27(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 17376))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 17408))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 17376))) /* Equivalent hex address = 0x342e43e0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_107_gemm_39_2_conv_355 */
  Conv_integer_sw_info conv_integer8_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 16320))) /* Equivalent hex address = 0x342e3fc0UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21024))) /* Equivalent hex address = 0x342e5220UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4560416))) /* Equivalent hex address = 0x71459620UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567344))) /* Equivalent hex address = 0x7145b130UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571568))) /* Equivalent hex address = 0x7145c1b0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567360))) /* Equivalent hex address = 0x7145b140UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571584))) /* Equivalent hex address = 0x7145c1c0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567376))) /* Equivalent hex address = 0x7145b150UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571600))) /* Equivalent hex address = 0x7145c1d0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 17280))) /* Equivalent hex address = 0x342e4380UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) /* Equivalent hex address = 0x342e8e80UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_107_gemm_39_2_conv_355 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer8_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 17280))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 17408))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 17280))) /* Equivalent hex address = 0x342e4380UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) /* Equivalent hex address = 0x342e8e80UL */, 960);

}


/* scheduling epoch=28   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_28(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 16416))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 16448))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 16416))) /* Equivalent hex address = 0x342e4020UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_107_gemm_35_1_conv_348 */
  Conv_integer_sw_info conv_integer9_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20112))) /* Equivalent hex address = 0x342e4e90UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4559520))) /* Equivalent hex address = 0x714592a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567008))) /* Equivalent hex address = 0x7145afe0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571232))) /* Equivalent hex address = 0x7145c060UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567024))) /* Equivalent hex address = 0x7145aff0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571248))) /* Equivalent hex address = 0x7145c070UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567040))) /* Equivalent hex address = 0x7145b000UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571264))) /* Equivalent hex address = 0x7145c080UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 16320))) /* Equivalent hex address = 0x342e3fc0UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) /* Equivalent hex address = 0x342e9240UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_107_gemm_35_1_conv_348 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer9_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 16320))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 16448))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 16320))) /* Equivalent hex address = 0x342e3fc0UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) /* Equivalent hex address = 0x342e9240UL */, 960);

}


// Epoch Controller Blob (name='_ec_blob_Default_29') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_29') start function
static void _ec_blob_cache_start_func_29(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */, 3840);

};


/* scheduling epoch=31   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_31(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42240))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_108_1 */
  static const uint32_t Transpose_108_1_tensor_shape_in_31_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_108_1_tensor_shape_in_31[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 34560,
      .offset_end = 38400,
      .offset_limit = 38464,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_108_1_tensor_shape_in_31_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_108_1_tensor_axes_offsets_in_31_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_108_1_tensor_axes_offsets_in_31[] = {
    Transpose_108_1_tensor_axes_offsets_in_31_0
  };

  static const uint32_t Transpose_108_1_tensor_shape_out_31_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_108_1_tensor_shape_out_31[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 38400,
      .offset_end = 42240,
      .offset_limit = 42304,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_108_1_tensor_shape_out_31_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_108_1_tensor_axes_offsets_out_31_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_108_1_tensor_axes_offsets_out_31[] = {
    Transpose_108_1_tensor_axes_offsets_out_31_0
  };

  static const uint8_t Transpose_108_1_perm_to_use_array_in_31[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_108_1_target_pos_array_in_31[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_108_1_tensor_shape_in_31[0], Transpose_108_1_tensor_axes_offsets_in_31[0], &Transpose_108_1_tensor_shape_out_31[0], Transpose_108_1_tensor_axes_offsets_out_31[0], Transpose_108_1_target_pos_array_in_31, Transpose_108_1_perm_to_use_array_in_31, 0, 1);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42240))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_32') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_32') start function
static void _ec_blob_cache_start_func_32(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42304))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) /* Equivalent hex address = 0x342ea520UL */, 32);

};


/* scheduling epoch=40   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_40(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38496))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38528))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38496))) /* Equivalent hex address = 0x342e9660UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=DequantizeLinear node=DequantizeLinear_inserted_id2408 */
  Dequantizelinear_sw_info dequantizelinear10_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) /* Equivalent hex address = 0x342ea520UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569312))) /* Equivalent hex address = 0x7145b8e0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573536))) /* Equivalent hex address = 0x7145c960UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_DEQUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node DequantizeLinear_inserted_id2408 mapped on EmbedNets (INTEGER) as DequantizeLinear | Category: Format-Converter */
  ll_sw_forward_dequantizelinear(&dequantizelinear10_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38528))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 128);

}


/* scheduling epoch=41   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_41(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) /* Equivalent hex address = 0x342e0060UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Reciprocal node=Reciprocal_130 */
  Activ_sw_info activ11_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.input.format.is_signed = 0,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_RECIPROCAL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Reciprocal_130 mapped on EmbedNets (FLOAT) as Reciprocal | Category: Computational */
  ll_sw_forward_activ(&activ11_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 128);

}


/* scheduling epoch=42   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_42(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38432))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2416 */
  Quantizelinear_sw_info quantizelinear12_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569504))) /* Equivalent hex address = 0x7145b9a0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573728))) /* Equivalent hex address = 0x7145ca20UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2416 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear12_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38432))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 32);

}


/* scheduling epoch=43   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_43(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Mul node=Mul_131 */
  Eltwise_integer_sw_info eltwise_integer13_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 1,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 128,
    .operand.stride.b = 128,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4556448))) /* Equivalent hex address = 0x714586a0UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565664))) /* Equivalent hex address = 0x7145aaa0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569888))) /* Equivalent hex address = 0x7145bb20UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565680))) /* Equivalent hex address = 0x7145aab0UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569904))) /* Equivalent hex address = 0x7145bb30UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565696))) /* Equivalent hex address = 0x7145aac0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569920))) /* Equivalent hex address = 0x7145bb40UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 7680,
    .general.output.stride.h = 256,
    .general.output.stride.w = 2,
    .general.output.stride.c = 2,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHMUL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Mul_131 mapped on EmbedNets (INTEGER) as Mul | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer13_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 7680);

}


/* scheduling epoch=44   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_44(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2417 */
  Quantizelinear_sw_info quantizelinear14_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569520))) /* Equivalent hex address = 0x7145b9b0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573744))) /* Equivalent hex address = 0x7145ca30UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2417 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear14_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);

}


// Epoch Controller Blob (name='_ec_blob_Default_45') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_45') start function
static void _ec_blob_cache_start_func_45(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 30752))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) /* Equivalent hex address = 0x342e6920UL */, 3840);

};


/* scheduling epoch=47   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_47(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Sub node=Sub_137 */
  Eltwise_integer_sw_info eltwise_integer15_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 128,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 128,
    .general.input.stride.b = 128,
    .general.input.stride.h = 128,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4557984))) /* Equivalent hex address = 0x71458ca0UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 30,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 3840,
    .operand.stride.b = 3840,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) /* Equivalent hex address = 0x342e6920UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566432))) /* Equivalent hex address = 0x7145ada0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570656))) /* Equivalent hex address = 0x7145be20UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566448))) /* Equivalent hex address = 0x7145adb0UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570672))) /* Equivalent hex address = 0x7145be30UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566464))) /* Equivalent hex address = 0x7145adc0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570688))) /* Equivalent hex address = 0x7145be40UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 3840,
    .general.output.stride.h = 128,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHSUB,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Sub_137 mapped on EmbedNets (INTEGER) as Sub | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer15_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_48') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_48') start function
static void _ec_blob_cache_start_func_48(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);

};


/* scheduling epoch=60   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_60(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) /* Equivalent hex address = 0x342e0060UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=DequantizeLinear node=DequantizeLinear_inserted_id2458 */
  Dequantizelinear_sw_info dequantizelinear16_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569328))) /* Equivalent hex address = 0x7145b8f0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573552))) /* Equivalent hex address = 0x7145c970UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_DEQUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node DequantizeLinear_inserted_id2458 mapped on EmbedNets (INTEGER) as DequantizeLinear | Category: Format-Converter */
  ll_sw_forward_dequantizelinear(&dequantizelinear16_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 128);

}


/* scheduling epoch=61   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_61(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19328))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19328))) /* Equivalent hex address = 0x342e4b80UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Reciprocal node=Reciprocal_174 */
  Activ_sw_info activ17_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_RECIPROCAL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Reciprocal_174 mapped on EmbedNets (FLOAT) as Reciprocal | Category: Computational */
  ll_sw_forward_activ(&activ17_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */, 128);

}


/* scheduling epoch=62   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_62(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2466 */
  Quantizelinear_sw_info quantizelinear18_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569536))) /* Equivalent hex address = 0x7145b9c0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573760))) /* Equivalent hex address = 0x7145ca40UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2466 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear18_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);

}


/* scheduling epoch=63   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_63(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Mul node=Mul_175 */
  Eltwise_integer_sw_info eltwise_integer19_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 1,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 128,
    .operand.stride.b = 128,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4556576))) /* Equivalent hex address = 0x71458720UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565712))) /* Equivalent hex address = 0x7145aad0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569936))) /* Equivalent hex address = 0x7145bb50UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565728))) /* Equivalent hex address = 0x7145aae0UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569952))) /* Equivalent hex address = 0x7145bb60UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565744))) /* Equivalent hex address = 0x7145aaf0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569968))) /* Equivalent hex address = 0x7145bb70UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 7680,
    .general.output.stride.h = 256,
    .general.output.stride.w = 2,
    .general.output.stride.c = 2,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHMUL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Mul_175 mapped on EmbedNets (INTEGER) as Mul | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer19_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 7680);

}


/* scheduling epoch=64   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_64(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2467 */
  Quantizelinear_sw_info quantizelinear20_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569552))) /* Equivalent hex address = 0x7145b9d0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573776))) /* Equivalent hex address = 0x7145ca50UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2467 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear20_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);

}


// Epoch Controller Blob (name='_ec_blob_Default_65') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_65') start function
static void _ec_blob_cache_start_func_65(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

};


/* scheduling epoch=67   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_67(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Sub node=Sub_181 */
  Eltwise_integer_sw_info eltwise_integer21_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 128,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 128,
    .general.input.stride.b = 128,
    .general.input.stride.h = 128,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4558112))) /* Equivalent hex address = 0x71458d20UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 30,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 3840,
    .operand.stride.b = 3840,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566480))) /* Equivalent hex address = 0x7145add0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570704))) /* Equivalent hex address = 0x7145be50UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566496))) /* Equivalent hex address = 0x7145ade0UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570720))) /* Equivalent hex address = 0x7145be60UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566512))) /* Equivalent hex address = 0x7145adf0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570736))) /* Equivalent hex address = 0x7145be70UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 3840,
    .general.output.stride.h = 128,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHSUB,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Sub_181 mapped on EmbedNets (INTEGER) as Sub | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer21_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_68') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_68') start function
static void _ec_blob_cache_start_func_68(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 3840);

};


/* scheduling epoch=74   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_74(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_199 */
  static const uint32_t Transpose_199_tensor_shape_in_74_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_199_tensor_shape_in_74[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 7680,
      .offset_end = 11520,
      .offset_limit = 11584,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_199_tensor_shape_in_74_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_199_tensor_axes_offsets_in_74_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_199_tensor_axes_offsets_in_74[] = {
    Transpose_199_tensor_axes_offsets_in_74_0
  };

  static const uint32_t Transpose_199_tensor_shape_out_74_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_199_tensor_shape_out_74[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 11520,
      .offset_end = 15360,
      .offset_limit = 15424,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_199_tensor_shape_out_74_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_199_tensor_axes_offsets_out_74_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_199_tensor_axes_offsets_out_74[] = {
    Transpose_199_tensor_axes_offsets_out_74_0
  };

  static const uint8_t Transpose_199_perm_to_use_array_in_74[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_199_target_pos_array_in_74[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_199_tensor_shape_in_74[0], Transpose_199_tensor_axes_offsets_in_74[0], &Transpose_199_tensor_shape_out_74[0], Transpose_199_tensor_axes_offsets_out_74[0], Transpose_199_target_pos_array_in_74, Transpose_199_perm_to_use_array_in_74, 6, 7);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_75') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_75') start function
static void _ec_blob_cache_start_func_75(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 3840);

};


/* scheduling epoch=76   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_76(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_207 */
  static const uint32_t Transpose_207_tensor_shape_in_76_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_207_tensor_shape_in_76[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 7680,
      .offset_end = 11520,
      .offset_limit = 11584,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_207_tensor_shape_in_76_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_207_tensor_axes_offsets_in_76_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_207_tensor_axes_offsets_in_76[] = {
    Transpose_207_tensor_axes_offsets_in_76_0
  };

  static const uint32_t Transpose_207_tensor_shape_out_76_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_207_tensor_shape_out_76[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 0,
      .offset_end = 3840,
      .offset_limit = 3904,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_207_tensor_shape_out_76_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_207_tensor_axes_offsets_out_76_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_207_tensor_axes_offsets_out_76[] = {
    Transpose_207_tensor_axes_offsets_out_76_0
  };

  static const uint8_t Transpose_207_perm_to_use_array_in_76[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_207_target_pos_array_in_76[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_207_tensor_shape_in_76[0], Transpose_207_tensor_axes_offsets_in_76[0], &Transpose_207_tensor_shape_out_76[0], Transpose_207_tensor_axes_offsets_out_76[0], Transpose_207_target_pos_array_in_76, Transpose_207_perm_to_use_array_in_76, 2, 3);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_77') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_77') start function
static void _ec_blob_cache_start_func_77(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) /* Equivalent hex address = 0x342e0f00UL */, 7680);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */, 3840);

};


/* scheduling epoch=80   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_80(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15296))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15328))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15296))) /* Equivalent hex address = 0x342e3bc0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_217_gemm_55_0_conv_411 */
  Conv_integer_sw_info conv_integer22_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) /* Equivalent hex address = 0x342e0f00UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4563744))) /* Equivalent hex address = 0x7145a320UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568592))) /* Equivalent hex address = 0x7145b610UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572816))) /* Equivalent hex address = 0x7145c690UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568608))) /* Equivalent hex address = 0x7145b620UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572832))) /* Equivalent hex address = 0x7145c6a0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568624))) /* Equivalent hex address = 0x7145b630UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572848))) /* Equivalent hex address = 0x7145c6b0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) /* Equivalent hex address = 0x342e3840UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_217_gemm_55_0_conv_411 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer22_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15328))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) /* Equivalent hex address = 0x342e3840UL */, 928);

}


/* scheduling epoch=81   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_81(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8576))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8608))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8576))) /* Equivalent hex address = 0x342e2180UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11776))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11808))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11776))) /* Equivalent hex address = 0x342e2e00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_217_gemm_67_3_conv_432 */
  Conv_integer_sw_info conv_integer23_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 6720))) /* Equivalent hex address = 0x342e1a40UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4564000))) /* Equivalent hex address = 0x7145a420UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568688))) /* Equivalent hex address = 0x7145b670UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572912))) /* Equivalent hex address = 0x7145c6f0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568704))) /* Equivalent hex address = 0x7145b680UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572928))) /* Equivalent hex address = 0x7145c700UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568720))) /* Equivalent hex address = 0x7145b690UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572944))) /* Equivalent hex address = 0x7145c710UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11664))) /* Equivalent hex address = 0x342e2d90UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_217_gemm_67_3_conv_432 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer23_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8608))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 928);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11808))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 160);

}


/* scheduling epoch=82   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_82(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10688))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10720))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10688))) /* Equivalent hex address = 0x342e29c0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_217_gemm_63_2_conv_425 */
  Conv_integer_sw_info conv_integer24_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5760))) /* Equivalent hex address = 0x342e1680UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4563872))) /* Equivalent hex address = 0x7145a3a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568640))) /* Equivalent hex address = 0x7145b640UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572864))) /* Equivalent hex address = 0x7145c6c0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568656))) /* Equivalent hex address = 0x7145b650UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572880))) /* Equivalent hex address = 0x7145c6d0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568672))) /* Equivalent hex address = 0x7145b660UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572896))) /* Equivalent hex address = 0x7145c6e0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_217_gemm_63_2_conv_425 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer24_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 928);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10720))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */, 160);

}


/* scheduling epoch=83   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_83(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1024))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1056))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1024))) /* Equivalent hex address = 0x342e0400UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10496))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10528))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10496))) /* Equivalent hex address = 0x342e2900UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_217_gemm_59_1_conv_418 */
  Conv_integer_sw_info conv_integer25_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8640))) /* Equivalent hex address = 0x342e21c0UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4800))) /* Equivalent hex address = 0x342e12c0UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4562720))) /* Equivalent hex address = 0x71459f20UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568208))) /* Equivalent hex address = 0x7145b490UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572432))) /* Equivalent hex address = 0x7145c510UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568224))) /* Equivalent hex address = 0x7145b4a0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572448))) /* Equivalent hex address = 0x7145c520UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568240))) /* Equivalent hex address = 0x7145b4b0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572464))) /* Equivalent hex address = 0x7145c530UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 912))) /* Equivalent hex address = 0x342e0390UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_217_gemm_59_1_conv_418 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer25_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1056))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10528))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */, 928);

}


// Epoch Controller Blob (name='_ec_blob_Default_84') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_84') start function
static void _ec_blob_cache_start_func_84(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10784))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10784))) /* Equivalent hex address = 0x342e2a20UL */, 3616);

};


/* scheduling epoch=88   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_88(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4608))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4640))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4608))) /* Equivalent hex address = 0x342e1200UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Softmax node=Softmax_221 */
  Softmax_integer_sw_info softmax_integer26_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 4,
    .general.input.dim.num_elem = 3600,
    .general.input.stride.b = 3600,
    .general.input.stride.h = 120,
    .general.input.stride.w = 4,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10800))) /* Equivalent hex address = 0x342e2a30UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566240))) /* Equivalent hex address = 0x7145ace0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570464))) /* Equivalent hex address = 0x7145bd60UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566256))) /* Equivalent hex address = 0x7145acf0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570480))) /* Equivalent hex address = 0x7145bd70UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 257,
    .scratch.dim.tensor_c = 1,
    .scratch.dim.num_elem = 257,
    .scratch.stride.b = 1028,
    .scratch.stride.h = 1028,
    .scratch.stride.w = 4,
    .scratch.stride.c = 4,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3600))) /* Equivalent hex address = 0x342e0e10UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 4,
    .general.output.dim.num_elem = 3600,
    .general.output.stride.b = 3600,
    .general.output.stride.h = 120,
    .general.output.stride.w = 4,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .quantized_multiplier = 1358140416,
    .left_shift = 21,
    .diff_min = -992,
    .axis = 3,
    .general.type = LL_SW_SOFTMAX,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Softmax_221 mapped on EmbedNets (INTEGER) as Softmax | Category: Computational */
  ll_sw_forward_softmax_integer(&softmax_integer26_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4640))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 4640);

}


// Epoch Controller Blob (name='_ec_blob_Default_89') micro instructions needed


/* scheduling epoch=90   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_90(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 3648);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Split node=Softmax_221_out_0_72_split_B_76 */
  static const uint32_t Softmax_221_out_0_72_split_B_76_tensor_shape_in_90_shape_0[] = { 4, 30, 30 };
  static const LL_LIB_TensorShape_TypeDef Softmax_221_out_0_72_split_B_76_tensor_shape_in_90[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 0,
      .offset_end = 3600,
      .offset_limit = 3664,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_221_out_0_72_split_B_76_tensor_shape_in_90_shape_0,
      .batch = 4,
    }
  };

  static const uint32_t Softmax_221_out_0_72_split_B_76_tensor_shape_out_90_shape_0[] = { 1, 30, 30 };
  static const uint32_t Softmax_221_out_0_72_split_B_76_tensor_shape_out_90_shape_1[] = { 1, 30, 30 };
  static const uint32_t Softmax_221_out_0_72_split_B_76_tensor_shape_out_90_shape_2[] = { 1, 30, 30 };
  static const uint32_t Softmax_221_out_0_72_split_B_76_tensor_shape_out_90_shape_3[] = { 1, 30, 30 };
  static const LL_LIB_TensorShape_TypeDef Softmax_221_out_0_72_split_B_76_tensor_shape_out_90[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 19200,
      .offset_end = 20100,
      .offset_limit = 20168,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_221_out_0_72_split_B_76_tensor_shape_out_90_shape_0,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 20112,
      .offset_end = 21012,
      .offset_limit = 21080,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_221_out_0_72_split_B_76_tensor_shape_out_90_shape_1,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 21024,
      .offset_end = 21924,
      .offset_limit = 21992,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_221_out_0_72_split_B_76_tensor_shape_out_90_shape_2,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 21936,
      .offset_end = 22836,
      .offset_limit = 22904,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_221_out_0_72_split_B_76_tensor_shape_out_90_shape_3,
      .batch = 1,
    }
  };

  LL_ATON_LIB_Split(&Softmax_221_out_0_72_split_B_76_tensor_shape_in_90[0], true, &Softmax_221_out_0_72_split_B_76_tensor_shape_out_90, 4, 3, 0, 1, 3, 5, 6);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 3648);

}


// Epoch Controller Blob (name='_ec_blob_Default_91') micro instructions needed


/* scheduling epoch=92   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_92(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22944))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22976))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22944))) /* Equivalent hex address = 0x342e59a0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_222_gemm_83_1_conv_446 */
  Conv_integer_sw_info conv_integer27_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 18240))) /* Equivalent hex address = 0x342e4740UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20112))) /* Equivalent hex address = 0x342e4e90UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4560800))) /* Equivalent hex address = 0x714597a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567488))) /* Equivalent hex address = 0x7145b1c0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571712))) /* Equivalent hex address = 0x7145c240UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567504))) /* Equivalent hex address = 0x7145b1d0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571728))) /* Equivalent hex address = 0x7145c250UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567520))) /* Equivalent hex address = 0x7145b1e0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571744))) /* Equivalent hex address = 0x7145c260UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) /* Equivalent hex address = 0x342e5940UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_222_gemm_83_1_conv_446 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer27_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22976))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) /* Equivalent hex address = 0x342e5940UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */, 960);

}


/* scheduling epoch=93   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_93(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20096))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20128))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20096))) /* Equivalent hex address = 0x342e4e80UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20224))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20256))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20224))) /* Equivalent hex address = 0x342e4f00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_222_gemm_79_0_conv_439 */
  Conv_integer_sw_info conv_integer28_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 17280))) /* Equivalent hex address = 0x342e4380UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4560672))) /* Equivalent hex address = 0x71459720UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567440))) /* Equivalent hex address = 0x7145b190UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571664))) /* Equivalent hex address = 0x7145c210UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567456))) /* Equivalent hex address = 0x7145b1a0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571680))) /* Equivalent hex address = 0x7145c220UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567472))) /* Equivalent hex address = 0x7145b1b0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571696))) /* Equivalent hex address = 0x7145c230UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20112))) /* Equivalent hex address = 0x342e4e90UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) /* Equivalent hex address = 0x342e8ac0UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_222_gemm_79_0_conv_439 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer28_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20096))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20256))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20096))) /* Equivalent hex address = 0x342e4e80UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) /* Equivalent hex address = 0x342e8ac0UL */, 960);

}


/* scheduling epoch=94   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_94(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20224))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20256))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20224))) /* Equivalent hex address = 0x342e4f00UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20352))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20384))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20352))) /* Equivalent hex address = 0x342e4f80UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_222_gemm_91_3_conv_460 */
  Conv_integer_sw_info conv_integer29_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 16320))) /* Equivalent hex address = 0x342e3fc0UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21936))) /* Equivalent hex address = 0x342e55b0UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4560928))) /* Equivalent hex address = 0x71459820UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567536))) /* Equivalent hex address = 0x7145b1f0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571760))) /* Equivalent hex address = 0x7145c270UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567552))) /* Equivalent hex address = 0x7145b200UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571776))) /* Equivalent hex address = 0x7145c280UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567568))) /* Equivalent hex address = 0x7145b210UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571792))) /* Equivalent hex address = 0x7145c290UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20240))) /* Equivalent hex address = 0x342e4f10UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) /* Equivalent hex address = 0x342e8e80UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_222_gemm_91_3_conv_460 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer29_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20224))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20384))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20224))) /* Equivalent hex address = 0x342e4f00UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) /* Equivalent hex address = 0x342e8e80UL */, 960);

}


/* scheduling epoch=95   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_95(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20352))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20384))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20352))) /* Equivalent hex address = 0x342e4f80UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20480))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20512))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20480))) /* Equivalent hex address = 0x342e5000UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_222_gemm_87_2_conv_453 */
  Conv_integer_sw_info conv_integer30_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21024))) /* Equivalent hex address = 0x342e5220UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4559648))) /* Equivalent hex address = 0x71459320UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567056))) /* Equivalent hex address = 0x7145b010UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571280))) /* Equivalent hex address = 0x7145c090UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567072))) /* Equivalent hex address = 0x7145b020UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571296))) /* Equivalent hex address = 0x7145c0a0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567088))) /* Equivalent hex address = 0x7145b030UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571312))) /* Equivalent hex address = 0x7145c0b0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20368))) /* Equivalent hex address = 0x342e4f90UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) /* Equivalent hex address = 0x342e9240UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_222_gemm_87_2_conv_453 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer30_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20352))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20512))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20352))) /* Equivalent hex address = 0x342e4f80UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) /* Equivalent hex address = 0x342e9240UL */, 960);

}


// Epoch Controller Blob (name='_ec_blob_Default_96') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_96') start function
static void _ec_blob_cache_start_func_96(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */, 3840);

};


/* scheduling epoch=98   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_98(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42240))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_223 */
  static const uint32_t Transpose_223_tensor_shape_in_98_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_223_tensor_shape_in_98[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 34560,
      .offset_end = 38400,
      .offset_limit = 38464,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_223_tensor_shape_in_98_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_223_tensor_axes_offsets_in_98_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_223_tensor_axes_offsets_in_98[] = {
    Transpose_223_tensor_axes_offsets_in_98_0
  };

  static const uint32_t Transpose_223_tensor_shape_out_98_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_223_tensor_shape_out_98[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 38400,
      .offset_end = 42240,
      .offset_limit = 42304,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_223_tensor_shape_out_98_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_223_tensor_axes_offsets_out_98_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_223_tensor_axes_offsets_out_98[] = {
    Transpose_223_tensor_axes_offsets_out_98_0
  };

  static const uint8_t Transpose_223_perm_to_use_array_in_98[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_223_target_pos_array_in_98[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_223_tensor_shape_in_98[0], Transpose_223_tensor_axes_offsets_in_98[0], &Transpose_223_tensor_shape_out_98[0], Transpose_223_tensor_axes_offsets_out_98[0], Transpose_223_target_pos_array_in_98, Transpose_223_perm_to_use_array_in_98, 0, 1);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42240))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_99') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_99') start function
static void _ec_blob_cache_start_func_99(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42304))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) /* Equivalent hex address = 0x342ea520UL */, 32);

};


/* scheduling epoch=107  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_107(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38496))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38528))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38496))) /* Equivalent hex address = 0x342e9660UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=DequantizeLinear node=DequantizeLinear_inserted_id2547 */
  Dequantizelinear_sw_info dequantizelinear31_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) /* Equivalent hex address = 0x342ea520UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569344))) /* Equivalent hex address = 0x7145b900UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573568))) /* Equivalent hex address = 0x7145c980UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_DEQUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node DequantizeLinear_inserted_id2547 mapped on EmbedNets (INTEGER) as DequantizeLinear | Category: Format-Converter */
  ll_sw_forward_dequantizelinear(&dequantizelinear31_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38528))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 128);

}


/* scheduling epoch=108  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_108(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) /* Equivalent hex address = 0x342e0060UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Reciprocal node=Reciprocal_245 */
  Activ_sw_info activ32_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.input.format.is_signed = 0,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_RECIPROCAL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Reciprocal_245 mapped on EmbedNets (FLOAT) as Reciprocal | Category: Computational */
  ll_sw_forward_activ(&activ32_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 128);

}


/* scheduling epoch=109  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_109(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38432))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2555 */
  Quantizelinear_sw_info quantizelinear33_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569568))) /* Equivalent hex address = 0x7145b9e0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573792))) /* Equivalent hex address = 0x7145ca60UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2555 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear33_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38432))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 32);

}


/* scheduling epoch=110  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_110(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Mul node=Mul_246 */
  Eltwise_integer_sw_info eltwise_integer34_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 1,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 128,
    .operand.stride.b = 128,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4556704))) /* Equivalent hex address = 0x714587a0UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565760))) /* Equivalent hex address = 0x7145ab00UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569984))) /* Equivalent hex address = 0x7145bb80UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565776))) /* Equivalent hex address = 0x7145ab10UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570000))) /* Equivalent hex address = 0x7145bb90UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565792))) /* Equivalent hex address = 0x7145ab20UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570016))) /* Equivalent hex address = 0x7145bba0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 7680,
    .general.output.stride.h = 256,
    .general.output.stride.w = 2,
    .general.output.stride.c = 2,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHMUL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Mul_246 mapped on EmbedNets (INTEGER) as Mul | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer34_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 7680);

}


/* scheduling epoch=111  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_111(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2556 */
  Quantizelinear_sw_info quantizelinear35_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569584))) /* Equivalent hex address = 0x7145b9f0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573808))) /* Equivalent hex address = 0x7145ca70UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2556 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear35_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);

}


// Epoch Controller Blob (name='_ec_blob_Default_112') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_112') start function
static void _ec_blob_cache_start_func_112(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 30752))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) /* Equivalent hex address = 0x342e6920UL */, 3840);

};


/* scheduling epoch=114  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_114(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Sub node=Sub_252 */
  Eltwise_integer_sw_info eltwise_integer36_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 128,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 128,
    .general.input.stride.b = 128,
    .general.input.stride.h = 128,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4558240))) /* Equivalent hex address = 0x71458da0UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 30,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 3840,
    .operand.stride.b = 3840,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) /* Equivalent hex address = 0x342e6920UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566528))) /* Equivalent hex address = 0x7145ae00UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570752))) /* Equivalent hex address = 0x7145be80UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566544))) /* Equivalent hex address = 0x7145ae10UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570768))) /* Equivalent hex address = 0x7145be90UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566560))) /* Equivalent hex address = 0x7145ae20UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570784))) /* Equivalent hex address = 0x7145bea0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 3840,
    .general.output.stride.h = 128,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHSUB,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Sub_252 mapped on EmbedNets (INTEGER) as Sub | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer36_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_115') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_115') start function
static void _ec_blob_cache_start_func_115(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);

};


/* scheduling epoch=127  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_127(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) /* Equivalent hex address = 0x342e0060UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=DequantizeLinear node=DequantizeLinear_inserted_id2597 */
  Dequantizelinear_sw_info dequantizelinear37_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569360))) /* Equivalent hex address = 0x7145b910UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573584))) /* Equivalent hex address = 0x7145c990UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_DEQUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node DequantizeLinear_inserted_id2597 mapped on EmbedNets (INTEGER) as DequantizeLinear | Category: Format-Converter */
  ll_sw_forward_dequantizelinear(&dequantizelinear37_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 128);

}


/* scheduling epoch=128  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_128(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19328))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19328))) /* Equivalent hex address = 0x342e4b80UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Reciprocal node=Reciprocal_289 */
  Activ_sw_info activ38_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_RECIPROCAL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Reciprocal_289 mapped on EmbedNets (FLOAT) as Reciprocal | Category: Computational */
  ll_sw_forward_activ(&activ38_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */, 128);

}


/* scheduling epoch=129  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_129(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2605 */
  Quantizelinear_sw_info quantizelinear39_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569600))) /* Equivalent hex address = 0x7145ba00UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573824))) /* Equivalent hex address = 0x7145ca80UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2605 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear39_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);

}


/* scheduling epoch=130  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_130(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Mul node=Mul_290 */
  Eltwise_integer_sw_info eltwise_integer40_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 1,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 128,
    .operand.stride.b = 128,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4556832))) /* Equivalent hex address = 0x71458820UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565808))) /* Equivalent hex address = 0x7145ab30UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570032))) /* Equivalent hex address = 0x7145bbb0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565824))) /* Equivalent hex address = 0x7145ab40UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570048))) /* Equivalent hex address = 0x7145bbc0UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565840))) /* Equivalent hex address = 0x7145ab50UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570064))) /* Equivalent hex address = 0x7145bbd0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 7680,
    .general.output.stride.h = 256,
    .general.output.stride.w = 2,
    .general.output.stride.c = 2,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHMUL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Mul_290 mapped on EmbedNets (INTEGER) as Mul | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer40_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 7680);

}


/* scheduling epoch=131  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_131(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2606 */
  Quantizelinear_sw_info quantizelinear41_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569616))) /* Equivalent hex address = 0x7145ba10UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573840))) /* Equivalent hex address = 0x7145ca90UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2606 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear41_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);

}


// Epoch Controller Blob (name='_ec_blob_Default_132') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_132') start function
static void _ec_blob_cache_start_func_132(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

};


/* scheduling epoch=134  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_134(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Sub node=Sub_296 */
  Eltwise_integer_sw_info eltwise_integer42_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 128,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 128,
    .general.input.stride.b = 128,
    .general.input.stride.h = 128,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4558368))) /* Equivalent hex address = 0x71458e20UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 30,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 3840,
    .operand.stride.b = 3840,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566576))) /* Equivalent hex address = 0x7145ae30UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570800))) /* Equivalent hex address = 0x7145beb0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566592))) /* Equivalent hex address = 0x7145ae40UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570816))) /* Equivalent hex address = 0x7145bec0UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566608))) /* Equivalent hex address = 0x7145ae50UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570832))) /* Equivalent hex address = 0x7145bed0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 3840,
    .general.output.stride.h = 128,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHSUB,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Sub_296 mapped on EmbedNets (INTEGER) as Sub | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer42_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_135') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_135') start function
static void _ec_blob_cache_start_func_135(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 3840);

};


/* scheduling epoch=141  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_141(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_314 */
  static const uint32_t Transpose_314_tensor_shape_in_141_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_314_tensor_shape_in_141[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 7680,
      .offset_end = 11520,
      .offset_limit = 11584,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_314_tensor_shape_in_141_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_314_tensor_axes_offsets_in_141_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_314_tensor_axes_offsets_in_141[] = {
    Transpose_314_tensor_axes_offsets_in_141_0
  };

  static const uint32_t Transpose_314_tensor_shape_out_141_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_314_tensor_shape_out_141[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 11520,
      .offset_end = 15360,
      .offset_limit = 15424,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_314_tensor_shape_out_141_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_314_tensor_axes_offsets_out_141_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_314_tensor_axes_offsets_out_141[] = {
    Transpose_314_tensor_axes_offsets_out_141_0
  };

  static const uint8_t Transpose_314_perm_to_use_array_in_141[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_314_target_pos_array_in_141[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_314_tensor_shape_in_141[0], Transpose_314_tensor_axes_offsets_in_141[0], &Transpose_314_tensor_shape_out_141[0], Transpose_314_tensor_axes_offsets_out_141[0], Transpose_314_target_pos_array_in_141, Transpose_314_perm_to_use_array_in_141, 6, 7);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_142') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_142') start function
static void _ec_blob_cache_start_func_142(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 3840);

};


/* scheduling epoch=143  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_143(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_322 */
  static const uint32_t Transpose_322_tensor_shape_in_143_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_322_tensor_shape_in_143[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 7680,
      .offset_end = 11520,
      .offset_limit = 11584,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_322_tensor_shape_in_143_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_322_tensor_axes_offsets_in_143_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_322_tensor_axes_offsets_in_143[] = {
    Transpose_322_tensor_axes_offsets_in_143_0
  };

  static const uint32_t Transpose_322_tensor_shape_out_143_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_322_tensor_shape_out_143[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 0,
      .offset_end = 3840,
      .offset_limit = 3904,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_322_tensor_shape_out_143_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_322_tensor_axes_offsets_out_143_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_322_tensor_axes_offsets_out_143[] = {
    Transpose_322_tensor_axes_offsets_out_143_0
  };

  static const uint8_t Transpose_322_perm_to_use_array_in_143[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_322_target_pos_array_in_143[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_322_tensor_shape_in_143[0], Transpose_322_tensor_axes_offsets_in_143[0], &Transpose_322_tensor_shape_out_143[0], Transpose_322_tensor_axes_offsets_out_143[0], Transpose_322_target_pos_array_in_143, Transpose_322_perm_to_use_array_in_143, 2, 3);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_144') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_144') start function
static void _ec_blob_cache_start_func_144(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) /* Equivalent hex address = 0x342e0f00UL */, 7680);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */, 3840);

};


/* scheduling epoch=147  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_147(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15296))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15328))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15296))) /* Equivalent hex address = 0x342e3bc0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_332_gemm_115_3_conv_530 */
  Conv_integer_sw_info conv_integer43_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 6720))) /* Equivalent hex address = 0x342e1a40UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4564384))) /* Equivalent hex address = 0x7145a5a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568832))) /* Equivalent hex address = 0x7145b700UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573056))) /* Equivalent hex address = 0x7145c780UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568848))) /* Equivalent hex address = 0x7145b710UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573072))) /* Equivalent hex address = 0x7145c790UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568864))) /* Equivalent hex address = 0x7145b720UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573088))) /* Equivalent hex address = 0x7145c7a0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) /* Equivalent hex address = 0x342e3840UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_332_gemm_115_3_conv_530 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer43_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15328))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) /* Equivalent hex address = 0x342e3840UL */, 928);

}


/* scheduling epoch=148  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_148(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8576))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8608))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8576))) /* Equivalent hex address = 0x342e2180UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11776))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11808))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11776))) /* Equivalent hex address = 0x342e2e00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_332_gemm_111_2_conv_523 */
  Conv_integer_sw_info conv_integer44_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5760))) /* Equivalent hex address = 0x342e1680UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4564256))) /* Equivalent hex address = 0x7145a520UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568784))) /* Equivalent hex address = 0x7145b6d0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573008))) /* Equivalent hex address = 0x7145c750UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568800))) /* Equivalent hex address = 0x7145b6e0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573024))) /* Equivalent hex address = 0x7145c760UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568816))) /* Equivalent hex address = 0x7145b6f0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573040))) /* Equivalent hex address = 0x7145c770UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11664))) /* Equivalent hex address = 0x342e2d90UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_332_gemm_111_2_conv_523 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer44_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8608))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 928);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11808))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 160);

}


/* scheduling epoch=149  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_149(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10688))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10720))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10688))) /* Equivalent hex address = 0x342e29c0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_332_gemm_107_1_conv_516 */
  Conv_integer_sw_info conv_integer45_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4800))) /* Equivalent hex address = 0x342e12c0UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4564128))) /* Equivalent hex address = 0x7145a4a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568736))) /* Equivalent hex address = 0x7145b6a0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572960))) /* Equivalent hex address = 0x7145c720UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568752))) /* Equivalent hex address = 0x7145b6b0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572976))) /* Equivalent hex address = 0x7145c730UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568768))) /* Equivalent hex address = 0x7145b6c0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572992))) /* Equivalent hex address = 0x7145c740UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_332_gemm_107_1_conv_516 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer45_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 928);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10720))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */, 160);

}


/* scheduling epoch=150  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_150(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1024))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1056))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1024))) /* Equivalent hex address = 0x342e0400UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10496))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10528))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10496))) /* Equivalent hex address = 0x342e2900UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_332_gemm_103_0_conv_509 */
  Conv_integer_sw_info conv_integer46_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8640))) /* Equivalent hex address = 0x342e21c0UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) /* Equivalent hex address = 0x342e0f00UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4562848))) /* Equivalent hex address = 0x71459fa0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568256))) /* Equivalent hex address = 0x7145b4c0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572480))) /* Equivalent hex address = 0x7145c540UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568272))) /* Equivalent hex address = 0x7145b4d0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572496))) /* Equivalent hex address = 0x7145c550UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568288))) /* Equivalent hex address = 0x7145b4e0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572512))) /* Equivalent hex address = 0x7145c560UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 912))) /* Equivalent hex address = 0x342e0390UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_332_gemm_103_0_conv_509 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer46_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1056))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10528))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */, 928);

}


// Epoch Controller Blob (name='_ec_blob_Default_151') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_151') start function
static void _ec_blob_cache_start_func_151(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10784))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10784))) /* Equivalent hex address = 0x342e2a20UL */, 3616);

};


/* scheduling epoch=155  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_155(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4608))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4640))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4608))) /* Equivalent hex address = 0x342e1200UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Softmax node=Softmax_336 */
  Softmax_integer_sw_info softmax_integer47_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 4,
    .general.input.dim.num_elem = 3600,
    .general.input.stride.b = 3600,
    .general.input.stride.h = 120,
    .general.input.stride.w = 4,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10800))) /* Equivalent hex address = 0x342e2a30UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566272))) /* Equivalent hex address = 0x7145ad00UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570496))) /* Equivalent hex address = 0x7145bd80UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566288))) /* Equivalent hex address = 0x7145ad10UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570512))) /* Equivalent hex address = 0x7145bd90UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 257,
    .scratch.dim.tensor_c = 1,
    .scratch.dim.num_elem = 257,
    .scratch.stride.b = 1028,
    .scratch.stride.h = 1028,
    .scratch.stride.w = 4,
    .scratch.stride.c = 4,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3600))) /* Equivalent hex address = 0x342e0e10UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 4,
    .general.output.dim.num_elem = 3600,
    .general.output.stride.b = 3600,
    .general.output.stride.h = 120,
    .general.output.stride.w = 4,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .quantized_multiplier = 1685450880,
    .left_shift = 20,
    .diff_min = -1984,
    .axis = 3,
    .general.type = LL_SW_SOFTMAX,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Softmax_336 mapped on EmbedNets (INTEGER) as Softmax | Category: Computational */
  ll_sw_forward_softmax_integer(&softmax_integer47_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4640))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 4640);

}


// Epoch Controller Blob (name='_ec_blob_Default_156') micro instructions needed


/* scheduling epoch=157  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_157(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 3648);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Split node=Softmax_336_out_0_120_split_B_124 */
  static const uint32_t Softmax_336_out_0_120_split_B_124_tensor_shape_in_157_shape_0[] = { 4, 30, 30 };
  static const LL_LIB_TensorShape_TypeDef Softmax_336_out_0_120_split_B_124_tensor_shape_in_157[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 0,
      .offset_end = 3600,
      .offset_limit = 3664,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_336_out_0_120_split_B_124_tensor_shape_in_157_shape_0,
      .batch = 4,
    }
  };

  static const uint32_t Softmax_336_out_0_120_split_B_124_tensor_shape_out_157_shape_0[] = { 1, 30, 30 };
  static const uint32_t Softmax_336_out_0_120_split_B_124_tensor_shape_out_157_shape_1[] = { 1, 30, 30 };
  static const uint32_t Softmax_336_out_0_120_split_B_124_tensor_shape_out_157_shape_2[] = { 1, 30, 30 };
  static const uint32_t Softmax_336_out_0_120_split_B_124_tensor_shape_out_157_shape_3[] = { 1, 30, 30 };
  static const LL_LIB_TensorShape_TypeDef Softmax_336_out_0_120_split_B_124_tensor_shape_out_157[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 19200,
      .offset_end = 20100,
      .offset_limit = 20168,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_336_out_0_120_split_B_124_tensor_shape_out_157_shape_0,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 20112,
      .offset_end = 21012,
      .offset_limit = 21080,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_336_out_0_120_split_B_124_tensor_shape_out_157_shape_1,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 21024,
      .offset_end = 21924,
      .offset_limit = 21992,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_336_out_0_120_split_B_124_tensor_shape_out_157_shape_2,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 21936,
      .offset_end = 22836,
      .offset_limit = 22904,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_336_out_0_120_split_B_124_tensor_shape_out_157_shape_3,
      .batch = 1,
    }
  };

  LL_ATON_LIB_Split(&Softmax_336_out_0_120_split_B_124_tensor_shape_in_157[0], true, &Softmax_336_out_0_120_split_B_124_tensor_shape_out_157, 4, 3, 0, 1, 3, 5, 6);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 3648);

}


// Epoch Controller Blob (name='_ec_blob_Default_158') micro instructions needed


/* scheduling epoch=159  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_159(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22944))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22976))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22944))) /* Equivalent hex address = 0x342e59a0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_337_gemm_135_2_conv_551 */
  Conv_integer_sw_info conv_integer48_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 18240))) /* Equivalent hex address = 0x342e4740UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21024))) /* Equivalent hex address = 0x342e5220UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4561312))) /* Equivalent hex address = 0x714599a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567680))) /* Equivalent hex address = 0x7145b280UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571904))) /* Equivalent hex address = 0x7145c300UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567696))) /* Equivalent hex address = 0x7145b290UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571920))) /* Equivalent hex address = 0x7145c310UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567712))) /* Equivalent hex address = 0x7145b2a0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571936))) /* Equivalent hex address = 0x7145c320UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) /* Equivalent hex address = 0x342e5940UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_337_gemm_135_2_conv_551 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer48_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22976))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) /* Equivalent hex address = 0x342e5940UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */, 960);

}


/* scheduling epoch=160  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_160(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21120))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21152))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21120))) /* Equivalent hex address = 0x342e5280UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_337_gemm_131_1_conv_544 */
  Conv_integer_sw_info conv_integer49_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 17280))) /* Equivalent hex address = 0x342e4380UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20112))) /* Equivalent hex address = 0x342e4e90UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4561184))) /* Equivalent hex address = 0x71459920UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567632))) /* Equivalent hex address = 0x7145b250UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571856))) /* Equivalent hex address = 0x7145c2d0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567648))) /* Equivalent hex address = 0x7145b260UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571872))) /* Equivalent hex address = 0x7145c2e0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567664))) /* Equivalent hex address = 0x7145b270UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571888))) /* Equivalent hex address = 0x7145c2f0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21024))) /* Equivalent hex address = 0x342e5220UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) /* Equivalent hex address = 0x342e8ac0UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_337_gemm_131_1_conv_544 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer49_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21024))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21152))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21024))) /* Equivalent hex address = 0x342e5220UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) /* Equivalent hex address = 0x342e8ac0UL */, 960);

}


/* scheduling epoch=161  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_161(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21248))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21280))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21248))) /* Equivalent hex address = 0x342e5300UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_337_gemm_127_0_conv_537 */
  Conv_integer_sw_info conv_integer50_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 16320))) /* Equivalent hex address = 0x342e3fc0UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4561056))) /* Equivalent hex address = 0x714598a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567584))) /* Equivalent hex address = 0x7145b220UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571808))) /* Equivalent hex address = 0x7145c2a0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567600))) /* Equivalent hex address = 0x7145b230UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571824))) /* Equivalent hex address = 0x7145c2b0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567616))) /* Equivalent hex address = 0x7145b240UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571840))) /* Equivalent hex address = 0x7145c2c0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21152))) /* Equivalent hex address = 0x342e52a0UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) /* Equivalent hex address = 0x342e8e80UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_337_gemm_127_0_conv_537 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer50_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21152))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21280))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21152))) /* Equivalent hex address = 0x342e52a0UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) /* Equivalent hex address = 0x342e8e80UL */, 960);

}


/* scheduling epoch=162  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_162(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21376))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21408))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21376))) /* Equivalent hex address = 0x342e5380UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_337_gemm_139_3_conv_558 */
  Conv_integer_sw_info conv_integer51_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21936))) /* Equivalent hex address = 0x342e55b0UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4559776))) /* Equivalent hex address = 0x714593a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567104))) /* Equivalent hex address = 0x7145b040UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571328))) /* Equivalent hex address = 0x7145c0c0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567120))) /* Equivalent hex address = 0x7145b050UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571344))) /* Equivalent hex address = 0x7145c0d0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567136))) /* Equivalent hex address = 0x7145b060UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571360))) /* Equivalent hex address = 0x7145c0e0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21280))) /* Equivalent hex address = 0x342e5320UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) /* Equivalent hex address = 0x342e9240UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_337_gemm_139_3_conv_558 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer51_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21280))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21408))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21280))) /* Equivalent hex address = 0x342e5320UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) /* Equivalent hex address = 0x342e9240UL */, 960);

}


// Epoch Controller Blob (name='_ec_blob_Default_163') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_163') start function
static void _ec_blob_cache_start_func_163(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */, 3840);

};


/* scheduling epoch=165  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_165(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42240))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_338 */
  static const uint32_t Transpose_338_tensor_shape_in_165_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_338_tensor_shape_in_165[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 34560,
      .offset_end = 38400,
      .offset_limit = 38464,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_338_tensor_shape_in_165_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_338_tensor_axes_offsets_in_165_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_338_tensor_axes_offsets_in_165[] = {
    Transpose_338_tensor_axes_offsets_in_165_0
  };

  static const uint32_t Transpose_338_tensor_shape_out_165_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_338_tensor_shape_out_165[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 38400,
      .offset_end = 42240,
      .offset_limit = 42304,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_338_tensor_shape_out_165_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_338_tensor_axes_offsets_out_165_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_338_tensor_axes_offsets_out_165[] = {
    Transpose_338_tensor_axes_offsets_out_165_0
  };

  static const uint8_t Transpose_338_perm_to_use_array_in_165[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_338_target_pos_array_in_165[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_338_tensor_shape_in_165[0], Transpose_338_tensor_axes_offsets_in_165[0], &Transpose_338_tensor_shape_out_165[0], Transpose_338_tensor_axes_offsets_out_165[0], Transpose_338_target_pos_array_in_165, Transpose_338_perm_to_use_array_in_165, 0, 1);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42240))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_166') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_166') start function
static void _ec_blob_cache_start_func_166(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42304))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) /* Equivalent hex address = 0x342ea520UL */, 32);

};


/* scheduling epoch=174  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_174(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38496))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38528))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38496))) /* Equivalent hex address = 0x342e9660UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=DequantizeLinear node=DequantizeLinear_inserted_id2686 */
  Dequantizelinear_sw_info dequantizelinear52_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) /* Equivalent hex address = 0x342ea520UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569376))) /* Equivalent hex address = 0x7145b920UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573600))) /* Equivalent hex address = 0x7145c9a0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_DEQUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node DequantizeLinear_inserted_id2686 mapped on EmbedNets (INTEGER) as DequantizeLinear | Category: Format-Converter */
  ll_sw_forward_dequantizelinear(&dequantizelinear52_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38528))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 128);

}


/* scheduling epoch=175  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_175(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) /* Equivalent hex address = 0x342e0060UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Reciprocal node=Reciprocal_360 */
  Activ_sw_info activ53_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.input.format.is_signed = 0,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_RECIPROCAL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Reciprocal_360 mapped on EmbedNets (FLOAT) as Reciprocal | Category: Computational */
  ll_sw_forward_activ(&activ53_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 128);

}


/* scheduling epoch=176  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_176(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38432))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2694 */
  Quantizelinear_sw_info quantizelinear54_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569632))) /* Equivalent hex address = 0x7145ba20UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573856))) /* Equivalent hex address = 0x7145caa0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2694 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear54_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38432))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 32);

}


/* scheduling epoch=177  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_177(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Mul node=Mul_361 */
  Eltwise_integer_sw_info eltwise_integer55_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 1,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 128,
    .operand.stride.b = 128,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4556960))) /* Equivalent hex address = 0x714588a0UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565856))) /* Equivalent hex address = 0x7145ab60UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570080))) /* Equivalent hex address = 0x7145bbe0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565872))) /* Equivalent hex address = 0x7145ab70UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570096))) /* Equivalent hex address = 0x7145bbf0UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565888))) /* Equivalent hex address = 0x7145ab80UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570112))) /* Equivalent hex address = 0x7145bc00UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 7680,
    .general.output.stride.h = 256,
    .general.output.stride.w = 2,
    .general.output.stride.c = 2,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHMUL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Mul_361 mapped on EmbedNets (INTEGER) as Mul | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer55_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 7680);

}


/* scheduling epoch=178  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_178(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2695 */
  Quantizelinear_sw_info quantizelinear56_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569648))) /* Equivalent hex address = 0x7145ba30UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573872))) /* Equivalent hex address = 0x7145cab0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2695 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear56_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);

}


// Epoch Controller Blob (name='_ec_blob_Default_179') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_179') start function
static void _ec_blob_cache_start_func_179(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 30752))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) /* Equivalent hex address = 0x342e6920UL */, 3840);

};


/* scheduling epoch=181  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_181(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Sub node=Sub_367 */
  Eltwise_integer_sw_info eltwise_integer57_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 128,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 128,
    .general.input.stride.b = 128,
    .general.input.stride.h = 128,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4558496))) /* Equivalent hex address = 0x71458ea0UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 30,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 3840,
    .operand.stride.b = 3840,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) /* Equivalent hex address = 0x342e6920UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566624))) /* Equivalent hex address = 0x7145ae60UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570848))) /* Equivalent hex address = 0x7145bee0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566640))) /* Equivalent hex address = 0x7145ae70UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570864))) /* Equivalent hex address = 0x7145bef0UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566656))) /* Equivalent hex address = 0x7145ae80UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570880))) /* Equivalent hex address = 0x7145bf00UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 3840,
    .general.output.stride.h = 128,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHSUB,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Sub_367 mapped on EmbedNets (INTEGER) as Sub | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer57_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_182') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_182') start function
static void _ec_blob_cache_start_func_182(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);

};


/* scheduling epoch=194  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_194(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) /* Equivalent hex address = 0x342e0060UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=DequantizeLinear node=DequantizeLinear_inserted_id2736 */
  Dequantizelinear_sw_info dequantizelinear58_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569392))) /* Equivalent hex address = 0x7145b930UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573616))) /* Equivalent hex address = 0x7145c9b0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_DEQUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node DequantizeLinear_inserted_id2736 mapped on EmbedNets (INTEGER) as DequantizeLinear | Category: Format-Converter */
  ll_sw_forward_dequantizelinear(&dequantizelinear58_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 128);

}


/* scheduling epoch=195  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_195(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19328))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19328))) /* Equivalent hex address = 0x342e4b80UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Reciprocal node=Reciprocal_404 */
  Activ_sw_info activ59_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_RECIPROCAL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Reciprocal_404 mapped on EmbedNets (FLOAT) as Reciprocal | Category: Computational */
  ll_sw_forward_activ(&activ59_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */, 128);

}


/* scheduling epoch=196  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_196(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2744 */
  Quantizelinear_sw_info quantizelinear60_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569664))) /* Equivalent hex address = 0x7145ba40UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573888))) /* Equivalent hex address = 0x7145cac0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2744 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear60_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);

}


/* scheduling epoch=197  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_197(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Mul node=Mul_405 */
  Eltwise_integer_sw_info eltwise_integer61_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 1,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 128,
    .operand.stride.b = 128,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4557088))) /* Equivalent hex address = 0x71458920UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565904))) /* Equivalent hex address = 0x7145ab90UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570128))) /* Equivalent hex address = 0x7145bc10UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565920))) /* Equivalent hex address = 0x7145aba0UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570144))) /* Equivalent hex address = 0x7145bc20UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565936))) /* Equivalent hex address = 0x7145abb0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570160))) /* Equivalent hex address = 0x7145bc30UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 7680,
    .general.output.stride.h = 256,
    .general.output.stride.w = 2,
    .general.output.stride.c = 2,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHMUL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Mul_405 mapped on EmbedNets (INTEGER) as Mul | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer61_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 7680);

}


/* scheduling epoch=198  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_198(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2745 */
  Quantizelinear_sw_info quantizelinear62_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569680))) /* Equivalent hex address = 0x7145ba50UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573904))) /* Equivalent hex address = 0x7145cad0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2745 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear62_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);

}


// Epoch Controller Blob (name='_ec_blob_Default_199') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_199') start function
static void _ec_blob_cache_start_func_199(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

};


/* scheduling epoch=201  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_201(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Sub node=Sub_411 */
  Eltwise_integer_sw_info eltwise_integer63_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 128,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 128,
    .general.input.stride.b = 128,
    .general.input.stride.h = 128,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4558624))) /* Equivalent hex address = 0x71458f20UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 30,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 3840,
    .operand.stride.b = 3840,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566672))) /* Equivalent hex address = 0x7145ae90UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570896))) /* Equivalent hex address = 0x7145bf10UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566688))) /* Equivalent hex address = 0x7145aea0UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570912))) /* Equivalent hex address = 0x7145bf20UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566704))) /* Equivalent hex address = 0x7145aeb0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570928))) /* Equivalent hex address = 0x7145bf30UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 3840,
    .general.output.stride.h = 128,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHSUB,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Sub_411 mapped on EmbedNets (INTEGER) as Sub | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer63_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_202') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_202') start function
static void _ec_blob_cache_start_func_202(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 3840);

};


/* scheduling epoch=208  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_208(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_429 */
  static const uint32_t Transpose_429_tensor_shape_in_208_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_429_tensor_shape_in_208[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 7680,
      .offset_end = 11520,
      .offset_limit = 11584,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_429_tensor_shape_in_208_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_429_tensor_axes_offsets_in_208_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_429_tensor_axes_offsets_in_208[] = {
    Transpose_429_tensor_axes_offsets_in_208_0
  };

  static const uint32_t Transpose_429_tensor_shape_out_208_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_429_tensor_shape_out_208[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 11520,
      .offset_end = 15360,
      .offset_limit = 15424,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_429_tensor_shape_out_208_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_429_tensor_axes_offsets_out_208_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_429_tensor_axes_offsets_out_208[] = {
    Transpose_429_tensor_axes_offsets_out_208_0
  };

  static const uint8_t Transpose_429_perm_to_use_array_in_208[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_429_target_pos_array_in_208[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_429_tensor_shape_in_208[0], Transpose_429_tensor_axes_offsets_in_208[0], &Transpose_429_tensor_shape_out_208[0], Transpose_429_tensor_axes_offsets_out_208[0], Transpose_429_target_pos_array_in_208, Transpose_429_perm_to_use_array_in_208, 6, 7);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_209') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_209') start function
static void _ec_blob_cache_start_func_209(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 3840);

};


/* scheduling epoch=210  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_210(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_437 */
  static const uint32_t Transpose_437_tensor_shape_in_210_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_437_tensor_shape_in_210[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 7680,
      .offset_end = 11520,
      .offset_limit = 11584,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_437_tensor_shape_in_210_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_437_tensor_axes_offsets_in_210_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_437_tensor_axes_offsets_in_210[] = {
    Transpose_437_tensor_axes_offsets_in_210_0
  };

  static const uint32_t Transpose_437_tensor_shape_out_210_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_437_tensor_shape_out_210[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 0,
      .offset_end = 3840,
      .offset_limit = 3904,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_437_tensor_shape_out_210_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_437_tensor_axes_offsets_out_210_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_437_tensor_axes_offsets_out_210[] = {
    Transpose_437_tensor_axes_offsets_out_210_0
  };

  static const uint8_t Transpose_437_perm_to_use_array_in_210[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_437_target_pos_array_in_210[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_437_tensor_shape_in_210[0], Transpose_437_tensor_axes_offsets_in_210[0], &Transpose_437_tensor_shape_out_210[0], Transpose_437_tensor_axes_offsets_out_210[0], Transpose_437_target_pos_array_in_210, Transpose_437_perm_to_use_array_in_210, 2, 3);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_211') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_211') start function
static void _ec_blob_cache_start_func_211(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) /* Equivalent hex address = 0x342e0f00UL */, 7680);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */, 3840);

};


/* scheduling epoch=214  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_214(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15296))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15328))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15296))) /* Equivalent hex address = 0x342e3bc0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_447_gemm_151_0_conv_607 */
  Conv_integer_sw_info conv_integer64_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) /* Equivalent hex address = 0x342e0f00UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4564512))) /* Equivalent hex address = 0x7145a620UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568880))) /* Equivalent hex address = 0x7145b730UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573104))) /* Equivalent hex address = 0x7145c7b0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568896))) /* Equivalent hex address = 0x7145b740UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573120))) /* Equivalent hex address = 0x7145c7c0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568912))) /* Equivalent hex address = 0x7145b750UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573136))) /* Equivalent hex address = 0x7145c7d0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) /* Equivalent hex address = 0x342e3840UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_447_gemm_151_0_conv_607 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer64_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15328))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) /* Equivalent hex address = 0x342e3840UL */, 928);

}


/* scheduling epoch=215  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_215(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8576))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8608))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8576))) /* Equivalent hex address = 0x342e2180UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11776))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11808))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11776))) /* Equivalent hex address = 0x342e2e00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_447_gemm_163_3_conv_628 */
  Conv_integer_sw_info conv_integer65_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 6720))) /* Equivalent hex address = 0x342e1a40UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4564768))) /* Equivalent hex address = 0x7145a720UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568976))) /* Equivalent hex address = 0x7145b790UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573200))) /* Equivalent hex address = 0x7145c810UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568992))) /* Equivalent hex address = 0x7145b7a0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573216))) /* Equivalent hex address = 0x7145c820UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569008))) /* Equivalent hex address = 0x7145b7b0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573232))) /* Equivalent hex address = 0x7145c830UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11664))) /* Equivalent hex address = 0x342e2d90UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_447_gemm_163_3_conv_628 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer65_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8608))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 928);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11808))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 160);

}


/* scheduling epoch=216  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_216(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10688))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10720))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10688))) /* Equivalent hex address = 0x342e29c0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_447_gemm_159_2_conv_621 */
  Conv_integer_sw_info conv_integer66_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5760))) /* Equivalent hex address = 0x342e1680UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4564640))) /* Equivalent hex address = 0x7145a6a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568928))) /* Equivalent hex address = 0x7145b760UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573152))) /* Equivalent hex address = 0x7145c7e0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568944))) /* Equivalent hex address = 0x7145b770UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573168))) /* Equivalent hex address = 0x7145c7f0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568960))) /* Equivalent hex address = 0x7145b780UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573184))) /* Equivalent hex address = 0x7145c800UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_447_gemm_159_2_conv_621 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer66_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 928);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10720))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */, 160);

}


/* scheduling epoch=217  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_217(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1024))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1056))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1024))) /* Equivalent hex address = 0x342e0400UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10496))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10528))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10496))) /* Equivalent hex address = 0x342e2900UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_447_gemm_155_1_conv_614 */
  Conv_integer_sw_info conv_integer67_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8640))) /* Equivalent hex address = 0x342e21c0UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4800))) /* Equivalent hex address = 0x342e12c0UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4562976))) /* Equivalent hex address = 0x7145a020UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568304))) /* Equivalent hex address = 0x7145b4f0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572528))) /* Equivalent hex address = 0x7145c570UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568320))) /* Equivalent hex address = 0x7145b500UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572544))) /* Equivalent hex address = 0x7145c580UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568336))) /* Equivalent hex address = 0x7145b510UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572560))) /* Equivalent hex address = 0x7145c590UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 912))) /* Equivalent hex address = 0x342e0390UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_447_gemm_155_1_conv_614 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer67_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1056))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10528))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */, 928);

}


// Epoch Controller Blob (name='_ec_blob_Default_218') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_218') start function
static void _ec_blob_cache_start_func_218(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10784))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10784))) /* Equivalent hex address = 0x342e2a20UL */, 3616);

};


/* scheduling epoch=222  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_222(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4608))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4640))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4608))) /* Equivalent hex address = 0x342e1200UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Softmax node=Softmax_451 */
  Softmax_integer_sw_info softmax_integer68_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 4,
    .general.input.dim.num_elem = 3600,
    .general.input.stride.b = 3600,
    .general.input.stride.h = 120,
    .general.input.stride.w = 4,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10800))) /* Equivalent hex address = 0x342e2a30UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566304))) /* Equivalent hex address = 0x7145ad20UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570528))) /* Equivalent hex address = 0x7145bda0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566320))) /* Equivalent hex address = 0x7145ad30UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570544))) /* Equivalent hex address = 0x7145bdb0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 257,
    .scratch.dim.tensor_c = 1,
    .scratch.dim.num_elem = 257,
    .scratch.stride.b = 1028,
    .scratch.stride.h = 1028,
    .scratch.stride.w = 4,
    .scratch.stride.c = 4,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3600))) /* Equivalent hex address = 0x342e0e10UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 4,
    .general.output.dim.num_elem = 3600,
    .general.output.stride.b = 3600,
    .general.output.stride.h = 120,
    .general.output.stride.w = 4,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .quantized_multiplier = 1101706240,
    .left_shift = 20,
    .diff_min = -1984,
    .axis = 3,
    .general.type = LL_SW_SOFTMAX,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Softmax_451 mapped on EmbedNets (INTEGER) as Softmax | Category: Computational */
  ll_sw_forward_softmax_integer(&softmax_integer68_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4640))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 4640);

}


// Epoch Controller Blob (name='_ec_blob_Default_223') micro instructions needed


/* scheduling epoch=224  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_224(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 3648);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Split node=Softmax_451_out_0_168_split_B_172 */
  static const uint32_t Softmax_451_out_0_168_split_B_172_tensor_shape_in_224_shape_0[] = { 4, 30, 30 };
  static const LL_LIB_TensorShape_TypeDef Softmax_451_out_0_168_split_B_172_tensor_shape_in_224[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 0,
      .offset_end = 3600,
      .offset_limit = 3664,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_451_out_0_168_split_B_172_tensor_shape_in_224_shape_0,
      .batch = 4,
    }
  };

  static const uint32_t Softmax_451_out_0_168_split_B_172_tensor_shape_out_224_shape_0[] = { 1, 30, 30 };
  static const uint32_t Softmax_451_out_0_168_split_B_172_tensor_shape_out_224_shape_1[] = { 1, 30, 30 };
  static const uint32_t Softmax_451_out_0_168_split_B_172_tensor_shape_out_224_shape_2[] = { 1, 30, 30 };
  static const uint32_t Softmax_451_out_0_168_split_B_172_tensor_shape_out_224_shape_3[] = { 1, 30, 30 };
  static const LL_LIB_TensorShape_TypeDef Softmax_451_out_0_168_split_B_172_tensor_shape_out_224[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 19200,
      .offset_end = 20100,
      .offset_limit = 20168,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_451_out_0_168_split_B_172_tensor_shape_out_224_shape_0,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 20112,
      .offset_end = 21012,
      .offset_limit = 21080,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_451_out_0_168_split_B_172_tensor_shape_out_224_shape_1,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 21024,
      .offset_end = 21924,
      .offset_limit = 21992,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_451_out_0_168_split_B_172_tensor_shape_out_224_shape_2,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 21936,
      .offset_end = 22836,
      .offset_limit = 22904,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_451_out_0_168_split_B_172_tensor_shape_out_224_shape_3,
      .batch = 1,
    }
  };

  LL_ATON_LIB_Split(&Softmax_451_out_0_168_split_B_172_tensor_shape_in_224[0], true, &Softmax_451_out_0_168_split_B_172_tensor_shape_out_224, 4, 3, 0, 1, 3, 5, 6);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 3648);

}


// Epoch Controller Blob (name='_ec_blob_Default_225') micro instructions needed


/* scheduling epoch=226  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_226(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22944))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22976))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22944))) /* Equivalent hex address = 0x342e59a0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_452_gemm_183_2_conv_649 */
  Conv_integer_sw_info conv_integer69_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 18240))) /* Equivalent hex address = 0x342e4740UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21024))) /* Equivalent hex address = 0x342e5220UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4561696))) /* Equivalent hex address = 0x71459b20UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567824))) /* Equivalent hex address = 0x7145b310UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572048))) /* Equivalent hex address = 0x7145c390UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567840))) /* Equivalent hex address = 0x7145b320UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572064))) /* Equivalent hex address = 0x7145c3a0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567856))) /* Equivalent hex address = 0x7145b330UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572080))) /* Equivalent hex address = 0x7145c3b0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) /* Equivalent hex address = 0x342e5940UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_452_gemm_183_2_conv_649 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer69_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22976))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) /* Equivalent hex address = 0x342e5940UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */, 960);

}


/* scheduling epoch=227  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_227(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21120))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21152))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21120))) /* Equivalent hex address = 0x342e5280UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_452_gemm_179_1_conv_642 */
  Conv_integer_sw_info conv_integer70_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 17280))) /* Equivalent hex address = 0x342e4380UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20112))) /* Equivalent hex address = 0x342e4e90UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4561568))) /* Equivalent hex address = 0x71459aa0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567776))) /* Equivalent hex address = 0x7145b2e0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572000))) /* Equivalent hex address = 0x7145c360UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567792))) /* Equivalent hex address = 0x7145b2f0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572016))) /* Equivalent hex address = 0x7145c370UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567808))) /* Equivalent hex address = 0x7145b300UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572032))) /* Equivalent hex address = 0x7145c380UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21024))) /* Equivalent hex address = 0x342e5220UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) /* Equivalent hex address = 0x342e8ac0UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_452_gemm_179_1_conv_642 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer70_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21024))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21152))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21024))) /* Equivalent hex address = 0x342e5220UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) /* Equivalent hex address = 0x342e8ac0UL */, 960);

}


/* scheduling epoch=228  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_228(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21248))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21280))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21248))) /* Equivalent hex address = 0x342e5300UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_452_gemm_175_0_conv_635 */
  Conv_integer_sw_info conv_integer71_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 16320))) /* Equivalent hex address = 0x342e3fc0UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4561440))) /* Equivalent hex address = 0x71459a20UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567728))) /* Equivalent hex address = 0x7145b2b0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571952))) /* Equivalent hex address = 0x7145c330UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567744))) /* Equivalent hex address = 0x7145b2c0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571968))) /* Equivalent hex address = 0x7145c340UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567760))) /* Equivalent hex address = 0x7145b2d0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571984))) /* Equivalent hex address = 0x7145c350UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21152))) /* Equivalent hex address = 0x342e52a0UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) /* Equivalent hex address = 0x342e8e80UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_452_gemm_175_0_conv_635 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer71_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21152))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21280))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21152))) /* Equivalent hex address = 0x342e52a0UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) /* Equivalent hex address = 0x342e8e80UL */, 960);

}


/* scheduling epoch=229  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_229(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21376))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21408))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21376))) /* Equivalent hex address = 0x342e5380UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_452_gemm_187_3_conv_656 */
  Conv_integer_sw_info conv_integer72_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21936))) /* Equivalent hex address = 0x342e55b0UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4559904))) /* Equivalent hex address = 0x71459420UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567152))) /* Equivalent hex address = 0x7145b070UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571376))) /* Equivalent hex address = 0x7145c0f0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567168))) /* Equivalent hex address = 0x7145b080UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571392))) /* Equivalent hex address = 0x7145c100UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567184))) /* Equivalent hex address = 0x7145b090UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571408))) /* Equivalent hex address = 0x7145c110UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21280))) /* Equivalent hex address = 0x342e5320UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) /* Equivalent hex address = 0x342e9240UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_452_gemm_187_3_conv_656 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer72_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21280))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21408))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21280))) /* Equivalent hex address = 0x342e5320UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) /* Equivalent hex address = 0x342e9240UL */, 960);

}


// Epoch Controller Blob (name='_ec_blob_Default_230') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_230') start function
static void _ec_blob_cache_start_func_230(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */, 3840);

};


/* scheduling epoch=232  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_232(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42240))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_453 */
  static const uint32_t Transpose_453_tensor_shape_in_232_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_453_tensor_shape_in_232[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 34560,
      .offset_end = 38400,
      .offset_limit = 38464,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_453_tensor_shape_in_232_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_453_tensor_axes_offsets_in_232_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_453_tensor_axes_offsets_in_232[] = {
    Transpose_453_tensor_axes_offsets_in_232_0
  };

  static const uint32_t Transpose_453_tensor_shape_out_232_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_453_tensor_shape_out_232[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 38400,
      .offset_end = 42240,
      .offset_limit = 42304,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_453_tensor_shape_out_232_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_453_tensor_axes_offsets_out_232_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_453_tensor_axes_offsets_out_232[] = {
    Transpose_453_tensor_axes_offsets_out_232_0
  };

  static const uint8_t Transpose_453_perm_to_use_array_in_232[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_453_target_pos_array_in_232[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_453_tensor_shape_in_232[0], Transpose_453_tensor_axes_offsets_in_232[0], &Transpose_453_tensor_shape_out_232[0], Transpose_453_tensor_axes_offsets_out_232[0], Transpose_453_target_pos_array_in_232, Transpose_453_perm_to_use_array_in_232, 0, 1);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42240))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_233') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_233') start function
static void _ec_blob_cache_start_func_233(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42304))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) /* Equivalent hex address = 0x342ea520UL */, 32);

};


/* scheduling epoch=241  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_241(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38496))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38528))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38496))) /* Equivalent hex address = 0x342e9660UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=DequantizeLinear node=DequantizeLinear_inserted_id2825 */
  Dequantizelinear_sw_info dequantizelinear73_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) /* Equivalent hex address = 0x342ea520UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569408))) /* Equivalent hex address = 0x7145b940UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573632))) /* Equivalent hex address = 0x7145c9c0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_DEQUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node DequantizeLinear_inserted_id2825 mapped on EmbedNets (INTEGER) as DequantizeLinear | Category: Format-Converter */
  ll_sw_forward_dequantizelinear(&dequantizelinear73_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38528))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 128);

}


/* scheduling epoch=242  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_242(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) /* Equivalent hex address = 0x342e0060UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Reciprocal node=Reciprocal_475 */
  Activ_sw_info activ74_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.input.format.is_signed = 0,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_RECIPROCAL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Reciprocal_475 mapped on EmbedNets (FLOAT) as Reciprocal | Category: Computational */
  ll_sw_forward_activ(&activ74_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 128);

}


/* scheduling epoch=243  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_243(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38432))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2833 */
  Quantizelinear_sw_info quantizelinear75_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569696))) /* Equivalent hex address = 0x7145ba60UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573920))) /* Equivalent hex address = 0x7145cae0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2833 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear75_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38432))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 32);

}


/* scheduling epoch=244  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_244(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Mul node=Mul_476 */
  Eltwise_integer_sw_info eltwise_integer76_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 1,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 128,
    .operand.stride.b = 128,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4557216))) /* Equivalent hex address = 0x714589a0UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565952))) /* Equivalent hex address = 0x7145abc0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570176))) /* Equivalent hex address = 0x7145bc40UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565968))) /* Equivalent hex address = 0x7145abd0UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570192))) /* Equivalent hex address = 0x7145bc50UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565984))) /* Equivalent hex address = 0x7145abe0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570208))) /* Equivalent hex address = 0x7145bc60UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 7680,
    .general.output.stride.h = 256,
    .general.output.stride.w = 2,
    .general.output.stride.c = 2,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHMUL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Mul_476 mapped on EmbedNets (INTEGER) as Mul | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer76_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 7680);

}


/* scheduling epoch=245  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_245(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2834 */
  Quantizelinear_sw_info quantizelinear77_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569712))) /* Equivalent hex address = 0x7145ba70UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573936))) /* Equivalent hex address = 0x7145caf0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2834 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear77_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);

}


// Epoch Controller Blob (name='_ec_blob_Default_246') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_246') start function
static void _ec_blob_cache_start_func_246(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 30752))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) /* Equivalent hex address = 0x342e6920UL */, 3840);

};


/* scheduling epoch=248  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_248(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Sub node=Sub_482 */
  Eltwise_integer_sw_info eltwise_integer78_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 128,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 128,
    .general.input.stride.b = 128,
    .general.input.stride.h = 128,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4558752))) /* Equivalent hex address = 0x71458fa0UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 30,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 3840,
    .operand.stride.b = 3840,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) /* Equivalent hex address = 0x342e6920UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566720))) /* Equivalent hex address = 0x7145aec0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570944))) /* Equivalent hex address = 0x7145bf40UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566736))) /* Equivalent hex address = 0x7145aed0UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570960))) /* Equivalent hex address = 0x7145bf50UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566752))) /* Equivalent hex address = 0x7145aee0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570976))) /* Equivalent hex address = 0x7145bf60UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 3840,
    .general.output.stride.h = 128,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHSUB,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Sub_482 mapped on EmbedNets (INTEGER) as Sub | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer78_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_249') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_249') start function
static void _ec_blob_cache_start_func_249(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);

};


/* scheduling epoch=261  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_261(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) /* Equivalent hex address = 0x342e0060UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=DequantizeLinear node=DequantizeLinear_inserted_id2875 */
  Dequantizelinear_sw_info dequantizelinear79_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569424))) /* Equivalent hex address = 0x7145b950UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573648))) /* Equivalent hex address = 0x7145c9d0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_DEQUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node DequantizeLinear_inserted_id2875 mapped on EmbedNets (INTEGER) as DequantizeLinear | Category: Format-Converter */
  ll_sw_forward_dequantizelinear(&dequantizelinear79_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 128);

}


/* scheduling epoch=262  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_262(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19328))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19328))) /* Equivalent hex address = 0x342e4b80UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Reciprocal node=Reciprocal_519 */
  Activ_sw_info activ80_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_RECIPROCAL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Reciprocal_519 mapped on EmbedNets (FLOAT) as Reciprocal | Category: Computational */
  ll_sw_forward_activ(&activ80_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */, 128);

}


/* scheduling epoch=263  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_263(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2883 */
  Quantizelinear_sw_info quantizelinear81_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569728))) /* Equivalent hex address = 0x7145ba80UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573952))) /* Equivalent hex address = 0x7145cb00UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2883 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear81_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);

}


/* scheduling epoch=264  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_264(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Mul node=Mul_520 */
  Eltwise_integer_sw_info eltwise_integer82_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 1,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 128,
    .operand.stride.b = 128,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4557344))) /* Equivalent hex address = 0x71458a20UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566000))) /* Equivalent hex address = 0x7145abf0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570224))) /* Equivalent hex address = 0x7145bc70UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566016))) /* Equivalent hex address = 0x7145ac00UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570240))) /* Equivalent hex address = 0x7145bc80UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566032))) /* Equivalent hex address = 0x7145ac10UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570256))) /* Equivalent hex address = 0x7145bc90UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 7680,
    .general.output.stride.h = 256,
    .general.output.stride.w = 2,
    .general.output.stride.c = 2,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHMUL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Mul_520 mapped on EmbedNets (INTEGER) as Mul | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer82_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 7680);

}


/* scheduling epoch=265  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_265(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2884 */
  Quantizelinear_sw_info quantizelinear83_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569744))) /* Equivalent hex address = 0x7145ba90UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573968))) /* Equivalent hex address = 0x7145cb10UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2884 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear83_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);

}


// Epoch Controller Blob (name='_ec_blob_Default_266') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_266') start function
static void _ec_blob_cache_start_func_266(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

};


/* scheduling epoch=268  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_268(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Sub node=Sub_526 */
  Eltwise_integer_sw_info eltwise_integer84_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 128,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 128,
    .general.input.stride.b = 128,
    .general.input.stride.h = 128,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4558880))) /* Equivalent hex address = 0x71459020UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 30,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 3840,
    .operand.stride.b = 3840,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566768))) /* Equivalent hex address = 0x7145aef0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570992))) /* Equivalent hex address = 0x7145bf70UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566784))) /* Equivalent hex address = 0x7145af00UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571008))) /* Equivalent hex address = 0x7145bf80UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566800))) /* Equivalent hex address = 0x7145af10UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571024))) /* Equivalent hex address = 0x7145bf90UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 3840,
    .general.output.stride.h = 128,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHSUB,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Sub_526 mapped on EmbedNets (INTEGER) as Sub | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer84_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_269') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_269') start function
static void _ec_blob_cache_start_func_269(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 3840);

};


/* scheduling epoch=275  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_275(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_544 */
  static const uint32_t Transpose_544_tensor_shape_in_275_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_544_tensor_shape_in_275[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 7680,
      .offset_end = 11520,
      .offset_limit = 11584,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_544_tensor_shape_in_275_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_544_tensor_axes_offsets_in_275_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_544_tensor_axes_offsets_in_275[] = {
    Transpose_544_tensor_axes_offsets_in_275_0
  };

  static const uint32_t Transpose_544_tensor_shape_out_275_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_544_tensor_shape_out_275[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 11520,
      .offset_end = 15360,
      .offset_limit = 15424,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_544_tensor_shape_out_275_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_544_tensor_axes_offsets_out_275_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_544_tensor_axes_offsets_out_275[] = {
    Transpose_544_tensor_axes_offsets_out_275_0
  };

  static const uint8_t Transpose_544_perm_to_use_array_in_275[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_544_target_pos_array_in_275[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_544_tensor_shape_in_275[0], Transpose_544_tensor_axes_offsets_in_275[0], &Transpose_544_tensor_shape_out_275[0], Transpose_544_tensor_axes_offsets_out_275[0], Transpose_544_target_pos_array_in_275, Transpose_544_perm_to_use_array_in_275, 6, 7);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_276') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_276') start function
static void _ec_blob_cache_start_func_276(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 3840);

};


/* scheduling epoch=277  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_277(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_552 */
  static const uint32_t Transpose_552_tensor_shape_in_277_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_552_tensor_shape_in_277[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 7680,
      .offset_end = 11520,
      .offset_limit = 11584,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_552_tensor_shape_in_277_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_552_tensor_axes_offsets_in_277_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_552_tensor_axes_offsets_in_277[] = {
    Transpose_552_tensor_axes_offsets_in_277_0
  };

  static const uint32_t Transpose_552_tensor_shape_out_277_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_552_tensor_shape_out_277[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 0,
      .offset_end = 3840,
      .offset_limit = 3904,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_552_tensor_shape_out_277_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_552_tensor_axes_offsets_out_277_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_552_tensor_axes_offsets_out_277[] = {
    Transpose_552_tensor_axes_offsets_out_277_0
  };

  static const uint8_t Transpose_552_perm_to_use_array_in_277[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_552_target_pos_array_in_277[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_552_tensor_shape_in_277[0], Transpose_552_tensor_axes_offsets_in_277[0], &Transpose_552_tensor_shape_out_277[0], Transpose_552_tensor_axes_offsets_out_277[0], Transpose_552_target_pos_array_in_277, Transpose_552_perm_to_use_array_in_277, 2, 3);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_278') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_278') start function
static void _ec_blob_cache_start_func_278(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) /* Equivalent hex address = 0x342e0f00UL */, 7680);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */, 3840);

};


/* scheduling epoch=281  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_281(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15296))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15328))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15296))) /* Equivalent hex address = 0x342e3bc0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_562_gemm_203_1_conv_712 */
  Conv_integer_sw_info conv_integer85_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4800))) /* Equivalent hex address = 0x342e12c0UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565024))) /* Equivalent hex address = 0x7145a820UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569072))) /* Equivalent hex address = 0x7145b7f0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573296))) /* Equivalent hex address = 0x7145c870UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569088))) /* Equivalent hex address = 0x7145b800UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573312))) /* Equivalent hex address = 0x7145c880UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569104))) /* Equivalent hex address = 0x7145b810UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573328))) /* Equivalent hex address = 0x7145c890UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) /* Equivalent hex address = 0x342e3840UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_562_gemm_203_1_conv_712 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer85_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15328))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) /* Equivalent hex address = 0x342e3840UL */, 928);

}


/* scheduling epoch=282  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_282(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8576))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8608))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8576))) /* Equivalent hex address = 0x342e2180UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11776))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11808))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11776))) /* Equivalent hex address = 0x342e2e00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_562_gemm_211_3_conv_726 */
  Conv_integer_sw_info conv_integer86_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 6720))) /* Equivalent hex address = 0x342e1a40UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565152))) /* Equivalent hex address = 0x7145a8a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569120))) /* Equivalent hex address = 0x7145b820UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573344))) /* Equivalent hex address = 0x7145c8a0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569136))) /* Equivalent hex address = 0x7145b830UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573360))) /* Equivalent hex address = 0x7145c8b0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569152))) /* Equivalent hex address = 0x7145b840UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573376))) /* Equivalent hex address = 0x7145c8c0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11664))) /* Equivalent hex address = 0x342e2d90UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_562_gemm_211_3_conv_726 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer86_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8608))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 928);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11808))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 160);

}


/* scheduling epoch=283  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_283(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10688))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10720))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10688))) /* Equivalent hex address = 0x342e29c0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_562_gemm_199_0_conv_705 */
  Conv_integer_sw_info conv_integer87_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) /* Equivalent hex address = 0x342e0f00UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4564896))) /* Equivalent hex address = 0x7145a7a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569024))) /* Equivalent hex address = 0x7145b7c0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573248))) /* Equivalent hex address = 0x7145c840UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569040))) /* Equivalent hex address = 0x7145b7d0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573264))) /* Equivalent hex address = 0x7145c850UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569056))) /* Equivalent hex address = 0x7145b7e0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573280))) /* Equivalent hex address = 0x7145c860UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_562_gemm_199_0_conv_705 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer87_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 928);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10720))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */, 160);

}


/* scheduling epoch=284  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_284(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1024))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1056))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1024))) /* Equivalent hex address = 0x342e0400UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10496))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10528))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10496))) /* Equivalent hex address = 0x342e2900UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_562_gemm_207_2_conv_719 */
  Conv_integer_sw_info conv_integer88_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8640))) /* Equivalent hex address = 0x342e21c0UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5760))) /* Equivalent hex address = 0x342e1680UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4563104))) /* Equivalent hex address = 0x7145a0a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568352))) /* Equivalent hex address = 0x7145b520UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572576))) /* Equivalent hex address = 0x7145c5a0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568368))) /* Equivalent hex address = 0x7145b530UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572592))) /* Equivalent hex address = 0x7145c5b0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568384))) /* Equivalent hex address = 0x7145b540UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572608))) /* Equivalent hex address = 0x7145c5c0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 912))) /* Equivalent hex address = 0x342e0390UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_562_gemm_207_2_conv_719 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer88_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1056))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10528))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */, 928);

}


// Epoch Controller Blob (name='_ec_blob_Default_285') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_285') start function
static void _ec_blob_cache_start_func_285(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10784))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10784))) /* Equivalent hex address = 0x342e2a20UL */, 3616);

};


/* scheduling epoch=289  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_289(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4608))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4640))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4608))) /* Equivalent hex address = 0x342e1200UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Softmax node=Softmax_566 */
  Softmax_integer_sw_info softmax_integer89_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 4,
    .general.input.dim.num_elem = 3600,
    .general.input.stride.b = 3600,
    .general.input.stride.h = 120,
    .general.input.stride.w = 4,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10800))) /* Equivalent hex address = 0x342e2a30UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566336))) /* Equivalent hex address = 0x7145ad40UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570560))) /* Equivalent hex address = 0x7145bdc0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566352))) /* Equivalent hex address = 0x7145ad50UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570576))) /* Equivalent hex address = 0x7145bdd0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 257,
    .scratch.dim.tensor_c = 1,
    .scratch.dim.num_elem = 257,
    .scratch.stride.b = 1028,
    .scratch.stride.h = 1028,
    .scratch.stride.w = 4,
    .scratch.stride.c = 4,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3600))) /* Equivalent hex address = 0x342e0e10UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 4,
    .general.output.dim.num_elem = 3600,
    .general.output.stride.b = 3600,
    .general.output.stride.h = 120,
    .general.output.stride.w = 4,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .quantized_multiplier = 2006113024,
    .left_shift = 20,
    .diff_min = -1984,
    .axis = 3,
    .general.type = LL_SW_SOFTMAX,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Softmax_566 mapped on EmbedNets (INTEGER) as Softmax | Category: Computational */
  ll_sw_forward_softmax_integer(&softmax_integer89_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4640))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 4640);

}


// Epoch Controller Blob (name='_ec_blob_Default_290') micro instructions needed


/* scheduling epoch=291  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_291(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 3648);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Split node=Softmax_566_out_0_216_split_B_220 */
  static const uint32_t Softmax_566_out_0_216_split_B_220_tensor_shape_in_291_shape_0[] = { 4, 30, 30 };
  static const LL_LIB_TensorShape_TypeDef Softmax_566_out_0_216_split_B_220_tensor_shape_in_291[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 0,
      .offset_end = 3600,
      .offset_limit = 3664,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_566_out_0_216_split_B_220_tensor_shape_in_291_shape_0,
      .batch = 4,
    }
  };

  static const uint32_t Softmax_566_out_0_216_split_B_220_tensor_shape_out_291_shape_0[] = { 1, 30, 30 };
  static const uint32_t Softmax_566_out_0_216_split_B_220_tensor_shape_out_291_shape_1[] = { 1, 30, 30 };
  static const uint32_t Softmax_566_out_0_216_split_B_220_tensor_shape_out_291_shape_2[] = { 1, 30, 30 };
  static const uint32_t Softmax_566_out_0_216_split_B_220_tensor_shape_out_291_shape_3[] = { 1, 30, 30 };
  static const LL_LIB_TensorShape_TypeDef Softmax_566_out_0_216_split_B_220_tensor_shape_out_291[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 19200,
      .offset_end = 20100,
      .offset_limit = 20168,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_566_out_0_216_split_B_220_tensor_shape_out_291_shape_0,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 20112,
      .offset_end = 21012,
      .offset_limit = 21080,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_566_out_0_216_split_B_220_tensor_shape_out_291_shape_1,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 21024,
      .offset_end = 21924,
      .offset_limit = 21992,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_566_out_0_216_split_B_220_tensor_shape_out_291_shape_2,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 21936,
      .offset_end = 22836,
      .offset_limit = 22904,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_566_out_0_216_split_B_220_tensor_shape_out_291_shape_3,
      .batch = 1,
    }
  };

  LL_ATON_LIB_Split(&Softmax_566_out_0_216_split_B_220_tensor_shape_in_291[0], true, &Softmax_566_out_0_216_split_B_220_tensor_shape_out_291, 4, 3, 0, 1, 3, 5, 6);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 3648);

}


// Epoch Controller Blob (name='_ec_blob_Default_292') micro instructions needed


/* scheduling epoch=293  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_293(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22944))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22976))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22944))) /* Equivalent hex address = 0x342e59a0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_567_gemm_231_2_conv_747 */
  Conv_integer_sw_info conv_integer90_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 18240))) /* Equivalent hex address = 0x342e4740UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21024))) /* Equivalent hex address = 0x342e5220UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4562080))) /* Equivalent hex address = 0x71459ca0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567968))) /* Equivalent hex address = 0x7145b3a0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572192))) /* Equivalent hex address = 0x7145c420UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567984))) /* Equivalent hex address = 0x7145b3b0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572208))) /* Equivalent hex address = 0x7145c430UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568000))) /* Equivalent hex address = 0x7145b3c0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572224))) /* Equivalent hex address = 0x7145c440UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) /* Equivalent hex address = 0x342e5940UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_567_gemm_231_2_conv_747 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer90_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22976))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) /* Equivalent hex address = 0x342e5940UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */, 960);

}


/* scheduling epoch=294  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_294(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21120))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21152))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21120))) /* Equivalent hex address = 0x342e5280UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_567_gemm_227_1_conv_740 */
  Conv_integer_sw_info conv_integer91_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 17280))) /* Equivalent hex address = 0x342e4380UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20112))) /* Equivalent hex address = 0x342e4e90UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4561952))) /* Equivalent hex address = 0x71459c20UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567920))) /* Equivalent hex address = 0x7145b370UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572144))) /* Equivalent hex address = 0x7145c3f0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567936))) /* Equivalent hex address = 0x7145b380UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572160))) /* Equivalent hex address = 0x7145c400UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567952))) /* Equivalent hex address = 0x7145b390UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572176))) /* Equivalent hex address = 0x7145c410UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21024))) /* Equivalent hex address = 0x342e5220UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) /* Equivalent hex address = 0x342e8ac0UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_567_gemm_227_1_conv_740 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer91_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21024))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21152))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21024))) /* Equivalent hex address = 0x342e5220UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) /* Equivalent hex address = 0x342e8ac0UL */, 960);

}


/* scheduling epoch=295  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_295(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21248))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21280))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21248))) /* Equivalent hex address = 0x342e5300UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_567_gemm_223_0_conv_733 */
  Conv_integer_sw_info conv_integer92_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 16320))) /* Equivalent hex address = 0x342e3fc0UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4561824))) /* Equivalent hex address = 0x71459ba0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567872))) /* Equivalent hex address = 0x7145b340UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572096))) /* Equivalent hex address = 0x7145c3c0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567888))) /* Equivalent hex address = 0x7145b350UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572112))) /* Equivalent hex address = 0x7145c3d0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567904))) /* Equivalent hex address = 0x7145b360UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572128))) /* Equivalent hex address = 0x7145c3e0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21152))) /* Equivalent hex address = 0x342e52a0UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) /* Equivalent hex address = 0x342e8e80UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_567_gemm_223_0_conv_733 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer92_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21152))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21280))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21152))) /* Equivalent hex address = 0x342e52a0UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) /* Equivalent hex address = 0x342e8e80UL */, 960);

}


/* scheduling epoch=296  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_296(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21376))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21408))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21376))) /* Equivalent hex address = 0x342e5380UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_567_gemm_235_3_conv_754 */
  Conv_integer_sw_info conv_integer93_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21936))) /* Equivalent hex address = 0x342e55b0UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4560032))) /* Equivalent hex address = 0x714594a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567200))) /* Equivalent hex address = 0x7145b0a0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571424))) /* Equivalent hex address = 0x7145c120UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567216))) /* Equivalent hex address = 0x7145b0b0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571440))) /* Equivalent hex address = 0x7145c130UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567232))) /* Equivalent hex address = 0x7145b0c0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571456))) /* Equivalent hex address = 0x7145c140UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21280))) /* Equivalent hex address = 0x342e5320UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) /* Equivalent hex address = 0x342e9240UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_567_gemm_235_3_conv_754 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer93_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21280))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21408))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21280))) /* Equivalent hex address = 0x342e5320UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) /* Equivalent hex address = 0x342e9240UL */, 960);

}


// Epoch Controller Blob (name='_ec_blob_Default_297') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_297') start function
static void _ec_blob_cache_start_func_297(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */, 3840);

};


/* scheduling epoch=299  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_299(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42240))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_568 */
  static const uint32_t Transpose_568_tensor_shape_in_299_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_568_tensor_shape_in_299[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 34560,
      .offset_end = 38400,
      .offset_limit = 38464,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_568_tensor_shape_in_299_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_568_tensor_axes_offsets_in_299_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_568_tensor_axes_offsets_in_299[] = {
    Transpose_568_tensor_axes_offsets_in_299_0
  };

  static const uint32_t Transpose_568_tensor_shape_out_299_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_568_tensor_shape_out_299[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 38400,
      .offset_end = 42240,
      .offset_limit = 42304,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_568_tensor_shape_out_299_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_568_tensor_axes_offsets_out_299_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_568_tensor_axes_offsets_out_299[] = {
    Transpose_568_tensor_axes_offsets_out_299_0
  };

  static const uint8_t Transpose_568_perm_to_use_array_in_299[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_568_target_pos_array_in_299[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_568_tensor_shape_in_299[0], Transpose_568_tensor_axes_offsets_in_299[0], &Transpose_568_tensor_shape_out_299[0], Transpose_568_tensor_axes_offsets_out_299[0], Transpose_568_target_pos_array_in_299, Transpose_568_perm_to_use_array_in_299, 0, 1);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42240))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_300') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_300') start function
static void _ec_blob_cache_start_func_300(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42304))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) /* Equivalent hex address = 0x342ea520UL */, 32);

};


/* scheduling epoch=308  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_308(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38496))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38528))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38496))) /* Equivalent hex address = 0x342e9660UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=DequantizeLinear node=DequantizeLinear_inserted_id2964 */
  Dequantizelinear_sw_info dequantizelinear94_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) /* Equivalent hex address = 0x342ea520UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569440))) /* Equivalent hex address = 0x7145b960UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573664))) /* Equivalent hex address = 0x7145c9e0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_DEQUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node DequantizeLinear_inserted_id2964 mapped on EmbedNets (INTEGER) as DequantizeLinear | Category: Format-Converter */
  ll_sw_forward_dequantizelinear(&dequantizelinear94_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38528))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 128);

}


/* scheduling epoch=309  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_309(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) /* Equivalent hex address = 0x342e0060UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Reciprocal node=Reciprocal_590 */
  Activ_sw_info activ95_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.input.format.is_signed = 0,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_RECIPROCAL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Reciprocal_590 mapped on EmbedNets (FLOAT) as Reciprocal | Category: Computational */
  ll_sw_forward_activ(&activ95_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 128);

}


/* scheduling epoch=310  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_310(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38432))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2972 */
  Quantizelinear_sw_info quantizelinear96_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569760))) /* Equivalent hex address = 0x7145baa0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573984))) /* Equivalent hex address = 0x7145cb20UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2972 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear96_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38432))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 32);

}


/* scheduling epoch=311  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_311(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Mul node=Mul_591 */
  Eltwise_integer_sw_info eltwise_integer97_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 1,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 128,
    .operand.stride.b = 128,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4557472))) /* Equivalent hex address = 0x71458aa0UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566048))) /* Equivalent hex address = 0x7145ac20UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570272))) /* Equivalent hex address = 0x7145bca0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566064))) /* Equivalent hex address = 0x7145ac30UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570288))) /* Equivalent hex address = 0x7145bcb0UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566080))) /* Equivalent hex address = 0x7145ac40UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570304))) /* Equivalent hex address = 0x7145bcc0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 7680,
    .general.output.stride.h = 256,
    .general.output.stride.w = 2,
    .general.output.stride.c = 2,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHMUL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Mul_591 mapped on EmbedNets (INTEGER) as Mul | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer97_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 7680);

}


/* scheduling epoch=312  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_312(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id2973 */
  Quantizelinear_sw_info quantizelinear98_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569776))) /* Equivalent hex address = 0x7145bab0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4574000))) /* Equivalent hex address = 0x7145cb30UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id2973 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear98_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);

}


// Epoch Controller Blob (name='_ec_blob_Default_313') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_313') start function
static void _ec_blob_cache_start_func_313(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 30752))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) /* Equivalent hex address = 0x342e6920UL */, 3840);

};


/* scheduling epoch=315  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_315(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Sub node=Sub_597 */
  Eltwise_integer_sw_info eltwise_integer99_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 128,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 128,
    .general.input.stride.b = 128,
    .general.input.stride.h = 128,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4559008))) /* Equivalent hex address = 0x714590a0UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 30,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 3840,
    .operand.stride.b = 3840,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) /* Equivalent hex address = 0x342e6920UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566816))) /* Equivalent hex address = 0x7145af20UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571040))) /* Equivalent hex address = 0x7145bfa0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566832))) /* Equivalent hex address = 0x7145af30UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571056))) /* Equivalent hex address = 0x7145bfb0UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566848))) /* Equivalent hex address = 0x7145af40UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571072))) /* Equivalent hex address = 0x7145bfc0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 3840,
    .general.output.stride.h = 128,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHSUB,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Sub_597 mapped on EmbedNets (INTEGER) as Sub | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer99_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_316') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_316') start function
static void _ec_blob_cache_start_func_316(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);

};


/* scheduling epoch=328  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_328(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) /* Equivalent hex address = 0x342e0060UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=DequantizeLinear node=DequantizeLinear_inserted_id3014 */
  Dequantizelinear_sw_info dequantizelinear100_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569456))) /* Equivalent hex address = 0x7145b970UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573680))) /* Equivalent hex address = 0x7145c9f0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_DEQUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node DequantizeLinear_inserted_id3014 mapped on EmbedNets (INTEGER) as DequantizeLinear | Category: Format-Converter */
  ll_sw_forward_dequantizelinear(&dequantizelinear100_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 128);

}


/* scheduling epoch=329  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_329(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19328))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19328))) /* Equivalent hex address = 0x342e4b80UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Reciprocal node=Reciprocal_634 */
  Activ_sw_info activ101_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_RECIPROCAL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Reciprocal_634 mapped on EmbedNets (FLOAT) as Reciprocal | Category: Computational */
  ll_sw_forward_activ(&activ101_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */, 128);

}


/* scheduling epoch=330  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_330(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id3022 */
  Quantizelinear_sw_info quantizelinear102_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569792))) /* Equivalent hex address = 0x7145bac0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4574016))) /* Equivalent hex address = 0x7145cb40UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id3022 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear102_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);

}


/* scheduling epoch=331  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_331(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Mul node=Mul_635 */
  Eltwise_integer_sw_info eltwise_integer103_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 1,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 128,
    .operand.stride.b = 128,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4557600))) /* Equivalent hex address = 0x71458b20UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566096))) /* Equivalent hex address = 0x7145ac50UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570320))) /* Equivalent hex address = 0x7145bcd0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566112))) /* Equivalent hex address = 0x7145ac60UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570336))) /* Equivalent hex address = 0x7145bce0UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566128))) /* Equivalent hex address = 0x7145ac70UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570352))) /* Equivalent hex address = 0x7145bcf0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 7680,
    .general.output.stride.h = 256,
    .general.output.stride.w = 2,
    .general.output.stride.c = 2,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHMUL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Mul_635 mapped on EmbedNets (INTEGER) as Mul | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer103_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 7680);

}


/* scheduling epoch=332  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_332(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id3023 */
  Quantizelinear_sw_info quantizelinear104_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569808))) /* Equivalent hex address = 0x7145bad0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4574032))) /* Equivalent hex address = 0x7145cb50UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id3023 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear104_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);

}


// Epoch Controller Blob (name='_ec_blob_Default_333') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_333') start function
static void _ec_blob_cache_start_func_333(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

};


/* scheduling epoch=335  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_335(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Sub node=Sub_641 */
  Eltwise_integer_sw_info eltwise_integer105_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 128,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 128,
    .general.input.stride.b = 128,
    .general.input.stride.h = 128,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4559136))) /* Equivalent hex address = 0x71459120UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 30,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 3840,
    .operand.stride.b = 3840,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566864))) /* Equivalent hex address = 0x7145af50UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571088))) /* Equivalent hex address = 0x7145bfd0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566880))) /* Equivalent hex address = 0x7145af60UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571104))) /* Equivalent hex address = 0x7145bfe0UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566896))) /* Equivalent hex address = 0x7145af70UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571120))) /* Equivalent hex address = 0x7145bff0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 3840,
    .general.output.stride.h = 128,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHSUB,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Sub_641 mapped on EmbedNets (INTEGER) as Sub | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer105_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_336') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_336') start function
static void _ec_blob_cache_start_func_336(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 3840);

};


/* scheduling epoch=342  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_342(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_659 */
  static const uint32_t Transpose_659_tensor_shape_in_342_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_659_tensor_shape_in_342[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 7680,
      .offset_end = 11520,
      .offset_limit = 11584,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_659_tensor_shape_in_342_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_659_tensor_axes_offsets_in_342_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_659_tensor_axes_offsets_in_342[] = {
    Transpose_659_tensor_axes_offsets_in_342_0
  };

  static const uint32_t Transpose_659_tensor_shape_out_342_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_659_tensor_shape_out_342[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 11520,
      .offset_end = 15360,
      .offset_limit = 15424,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_659_tensor_shape_out_342_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_659_tensor_axes_offsets_out_342_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_659_tensor_axes_offsets_out_342[] = {
    Transpose_659_tensor_axes_offsets_out_342_0
  };

  static const uint8_t Transpose_659_perm_to_use_array_in_342[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_659_target_pos_array_in_342[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_659_tensor_shape_in_342[0], Transpose_659_tensor_axes_offsets_in_342[0], &Transpose_659_tensor_shape_out_342[0], Transpose_659_tensor_axes_offsets_out_342[0], Transpose_659_target_pos_array_in_342, Transpose_659_perm_to_use_array_in_342, 6, 7);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_343') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_343') start function
static void _ec_blob_cache_start_func_343(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 3840);

};


/* scheduling epoch=344  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_344(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_667 */
  static const uint32_t Transpose_667_tensor_shape_in_344_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_667_tensor_shape_in_344[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 7680,
      .offset_end = 11520,
      .offset_limit = 11584,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_667_tensor_shape_in_344_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_667_tensor_axes_offsets_in_344_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_667_tensor_axes_offsets_in_344[] = {
    Transpose_667_tensor_axes_offsets_in_344_0
  };

  static const uint32_t Transpose_667_tensor_shape_out_344_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_667_tensor_shape_out_344[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 0,
      .offset_end = 3840,
      .offset_limit = 3904,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_667_tensor_shape_out_344_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_667_tensor_axes_offsets_out_344_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_667_tensor_axes_offsets_out_344[] = {
    Transpose_667_tensor_axes_offsets_out_344_0
  };

  static const uint8_t Transpose_667_perm_to_use_array_in_344[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_667_target_pos_array_in_344[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_667_tensor_shape_in_344[0], Transpose_667_tensor_axes_offsets_in_344[0], &Transpose_667_tensor_shape_out_344[0], Transpose_667_tensor_axes_offsets_out_344[0], Transpose_667_target_pos_array_in_344, Transpose_667_perm_to_use_array_in_344, 2, 3);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_345') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_345') start function
static void _ec_blob_cache_start_func_345(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) /* Equivalent hex address = 0x342e0f00UL */, 7680);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */, 3840);

};


/* scheduling epoch=348  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_348(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15296))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15328))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15296))) /* Equivalent hex address = 0x342e3bc0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_677_gemm_255_2_conv_817 */
  Conv_integer_sw_info conv_integer106_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 5760))) /* Equivalent hex address = 0x342e1680UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565536))) /* Equivalent hex address = 0x7145aa20UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569264))) /* Equivalent hex address = 0x7145b8b0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573488))) /* Equivalent hex address = 0x7145c930UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569280))) /* Equivalent hex address = 0x7145b8c0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573504))) /* Equivalent hex address = 0x7145c940UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569296))) /* Equivalent hex address = 0x7145b8d0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573520))) /* Equivalent hex address = 0x7145c950UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) /* Equivalent hex address = 0x342e3840UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_677_gemm_255_2_conv_817 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer106_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15328))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) /* Equivalent hex address = 0x342e3840UL */, 928);

}


/* scheduling epoch=349  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_349(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8576))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8608))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8576))) /* Equivalent hex address = 0x342e2180UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11680))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11776))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11808))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11776))) /* Equivalent hex address = 0x342e2e00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_677_gemm_251_1_conv_810 */
  Conv_integer_sw_info conv_integer107_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4800))) /* Equivalent hex address = 0x342e12c0UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565408))) /* Equivalent hex address = 0x7145a9a0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569216))) /* Equivalent hex address = 0x7145b880UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573440))) /* Equivalent hex address = 0x7145c900UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569232))) /* Equivalent hex address = 0x7145b890UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573456))) /* Equivalent hex address = 0x7145c910UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569248))) /* Equivalent hex address = 0x7145b8a0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573472))) /* Equivalent hex address = 0x7145c920UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11664))) /* Equivalent hex address = 0x342e2d90UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_677_gemm_251_1_conv_810 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer107_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8608))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 7680))) /* Equivalent hex address = 0x342e1e00UL */, 928);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11808))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11648))) /* Equivalent hex address = 0x342e2d80UL */, 160);

}


/* scheduling epoch=350  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_350(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10688))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10720))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10688))) /* Equivalent hex address = 0x342e29c0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_677_gemm_247_0_conv_803 */
  Conv_integer_sw_info conv_integer108_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3840))) /* Equivalent hex address = 0x342e0f00UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4565280))) /* Equivalent hex address = 0x7145a920UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569168))) /* Equivalent hex address = 0x7145b850UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573392))) /* Equivalent hex address = 0x7145c8d0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569184))) /* Equivalent hex address = 0x7145b860UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573408))) /* Equivalent hex address = 0x7145c8e0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569200))) /* Equivalent hex address = 0x7145b870UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573424))) /* Equivalent hex address = 0x7145c8f0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_677_gemm_247_0_conv_803 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer108_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 928);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10720))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10560))) /* Equivalent hex address = 0x342e2940UL */, 160);

}


/* scheduling epoch=351  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_351(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 928))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1024))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1056))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1024))) /* Equivalent hex address = 0x342e0400UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10496))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10528))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10496))) /* Equivalent hex address = 0x342e2900UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_677_gemm_259_3_conv_824 */
  Conv_integer_sw_info conv_integer109_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 32,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 32,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 8640))) /* Equivalent hex address = 0x342e21c0UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 32,
    .weights.dim.num_elem = 960,
    .weights.stride.b = 32,
    .weights.stride.h = 32,
    .weights.stride.w = 32,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 6720))) /* Equivalent hex address = 0x342e1a40UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4563232))) /* Equivalent hex address = 0x7145a120UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568400))) /* Equivalent hex address = 0x7145b550UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572624))) /* Equivalent hex address = 0x7145c5d0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568416))) /* Equivalent hex address = 0x7145b560UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572640))) /* Equivalent hex address = 0x7145c5e0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568432))) /* Equivalent hex address = 0x7145b570UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572656))) /* Equivalent hex address = 0x7145c5f0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 131,
    .scratch.dim.num_elem = 131,
    .scratch.stride.b = 131,
    .scratch.stride.h = 131,
    .scratch.stride.w = 131,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 912))) /* Equivalent hex address = 0x342e0390UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 900,
    .general.output.stride.b = 900,
    .general.output.stride.h = 900,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_677_gemm_259_3_conv_824 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer109_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 1056))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 896))) /* Equivalent hex address = 0x342e0380UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10528))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 9600))) /* Equivalent hex address = 0x342e2580UL */, 928);

}


// Epoch Controller Blob (name='_ec_blob_Default_352') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_352') start function
static void _ec_blob_cache_start_func_352(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10784))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 14400))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10784))) /* Equivalent hex address = 0x342e2a20UL */, 3616);

};


/* scheduling epoch=356  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_356(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4608))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4640))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4608))) /* Equivalent hex address = 0x342e1200UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Softmax node=Softmax_681 */
  Softmax_integer_sw_info softmax_integer110_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 30,
    .general.input.dim.tensor_c = 4,
    .general.input.dim.num_elem = 3600,
    .general.input.stride.b = 3600,
    .general.input.stride.h = 120,
    .general.input.stride.w = 4,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 10800))) /* Equivalent hex address = 0x342e2a30UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566368))) /* Equivalent hex address = 0x7145ad60UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570592))) /* Equivalent hex address = 0x7145bde0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566384))) /* Equivalent hex address = 0x7145ad70UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570608))) /* Equivalent hex address = 0x7145bdf0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 257,
    .scratch.dim.tensor_c = 1,
    .scratch.dim.num_elem = 257,
    .scratch.stride.b = 1028,
    .scratch.stride.h = 1028,
    .scratch.stride.w = 4,
    .scratch.stride.c = 4,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 3600))) /* Equivalent hex address = 0x342e0e10UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 30,
    .general.output.dim.tensor_c = 4,
    .general.output.dim.num_elem = 3600,
    .general.output.stride.b = 3600,
    .general.output.stride.h = 120,
    .general.output.stride.w = 4,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .quantized_multiplier = 1934348288,
    .left_shift = 20,
    .diff_min = -1984,
    .axis = 3,
    .general.type = LL_SW_SOFTMAX,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Softmax_681 mapped on EmbedNets (INTEGER) as Softmax | Category: Computational */
  ll_sw_forward_softmax_integer(&softmax_integer110_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 4640))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 4640);

}


// Epoch Controller Blob (name='_ec_blob_Default_357') micro instructions needed


/* scheduling epoch=358  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_358(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 3648);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Split node=Softmax_681_out_0_264_split_B_268 */
  static const uint32_t Softmax_681_out_0_264_split_B_268_tensor_shape_in_358_shape_0[] = { 4, 30, 30 };
  static const LL_LIB_TensorShape_TypeDef Softmax_681_out_0_264_split_B_268_tensor_shape_in_358[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 0,
      .offset_end = 3600,
      .offset_limit = 3664,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_681_out_0_264_split_B_268_tensor_shape_in_358_shape_0,
      .batch = 4,
    }
  };

  static const uint32_t Softmax_681_out_0_264_split_B_268_tensor_shape_out_358_shape_0[] = { 1, 30, 30 };
  static const uint32_t Softmax_681_out_0_264_split_B_268_tensor_shape_out_358_shape_1[] = { 1, 30, 30 };
  static const uint32_t Softmax_681_out_0_264_split_B_268_tensor_shape_out_358_shape_2[] = { 1, 30, 30 };
  static const uint32_t Softmax_681_out_0_264_split_B_268_tensor_shape_out_358_shape_3[] = { 1, 30, 30 };
  static const LL_LIB_TensorShape_TypeDef Softmax_681_out_0_264_split_B_268_tensor_shape_out_358[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 19200,
      .offset_end = 20100,
      .offset_limit = 20168,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_681_out_0_264_split_B_268_tensor_shape_out_358_shape_0,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 20112,
      .offset_end = 21012,
      .offset_limit = 21080,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_681_out_0_264_split_B_268_tensor_shape_out_358_shape_1,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 21024,
      .offset_end = 21924,
      .offset_limit = 21992,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_681_out_0_264_split_B_268_tensor_shape_out_358_shape_2,
      .batch = 1,
    },
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 21936,
      .offset_end = 22836,
      .offset_limit = 22904,
      .ndims = 3,
      .nbits = 8,
      .shape = Softmax_681_out_0_264_split_B_268_tensor_shape_out_358_shape_3,
      .batch = 1,
    }
  };

  LL_ATON_LIB_Split(&Softmax_681_out_0_264_split_B_268_tensor_shape_in_358[0], true, &Softmax_681_out_0_264_split_B_268_tensor_shape_out_358, 4, 3, 0, 1, 3, 5, 6);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 3648);

}


// Epoch Controller Blob (name='_ec_blob_Default_359') micro instructions needed


/* scheduling epoch=360  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_360(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22944))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22976))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22944))) /* Equivalent hex address = 0x342e59a0UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_682_gemm_275_1_conv_838 */
  Conv_integer_sw_info conv_integer111_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 18240))) /* Equivalent hex address = 0x342e4740UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20112))) /* Equivalent hex address = 0x342e4e90UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4562336))) /* Equivalent hex address = 0x71459da0UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568064))) /* Equivalent hex address = 0x7145b400UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572288))) /* Equivalent hex address = 0x7145c480UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568080))) /* Equivalent hex address = 0x7145b410UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572304))) /* Equivalent hex address = 0x7145c490UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568096))) /* Equivalent hex address = 0x7145b420UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572320))) /* Equivalent hex address = 0x7145c4a0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) /* Equivalent hex address = 0x342e5940UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_682_gemm_275_1_conv_838 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer111_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22976))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 22848))) /* Equivalent hex address = 0x342e5940UL */, 128);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */, 960);

}


/* scheduling epoch=361  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_361(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20096))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20128))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20096))) /* Equivalent hex address = 0x342e4e80UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20224))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20256))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20224))) /* Equivalent hex address = 0x342e4f00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_682_gemm_271_0_conv_831 */
  Conv_integer_sw_info conv_integer112_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 17280))) /* Equivalent hex address = 0x342e4380UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4562208))) /* Equivalent hex address = 0x71459d20UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568016))) /* Equivalent hex address = 0x7145b3d0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572240))) /* Equivalent hex address = 0x7145c450UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568032))) /* Equivalent hex address = 0x7145b3e0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572256))) /* Equivalent hex address = 0x7145c460UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568048))) /* Equivalent hex address = 0x7145b3f0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572272))) /* Equivalent hex address = 0x7145c470UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20112))) /* Equivalent hex address = 0x342e4e90UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) /* Equivalent hex address = 0x342e8ac0UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_682_gemm_271_0_conv_831 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer112_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20096))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20256))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20096))) /* Equivalent hex address = 0x342e4e80UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 35520))) /* Equivalent hex address = 0x342e8ac0UL */, 960);

}


/* scheduling epoch=362  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_362(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20224))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20256))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20224))) /* Equivalent hex address = 0x342e4f00UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20352))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20384))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20352))) /* Equivalent hex address = 0x342e4f80UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_682_gemm_283_3_conv_852 */
  Conv_integer_sw_info conv_integer113_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 16320))) /* Equivalent hex address = 0x342e3fc0UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21936))) /* Equivalent hex address = 0x342e55b0UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4562464))) /* Equivalent hex address = 0x71459e20UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568112))) /* Equivalent hex address = 0x7145b430UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572336))) /* Equivalent hex address = 0x7145c4b0UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568128))) /* Equivalent hex address = 0x7145b440UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572352))) /* Equivalent hex address = 0x7145c4c0UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4568144))) /* Equivalent hex address = 0x7145b450UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4572368))) /* Equivalent hex address = 0x7145c4d0UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20240))) /* Equivalent hex address = 0x342e4f10UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) /* Equivalent hex address = 0x342e8e80UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_682_gemm_283_3_conv_852 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer113_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20224))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20384))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20224))) /* Equivalent hex address = 0x342e4f00UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 36480))) /* Equivalent hex address = 0x342e8e80UL */, 960);

}


/* scheduling epoch=363  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_363(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start address (first line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20352))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20384))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20352))) /* Equivalent hex address = 0x342e4f80UL */, 32);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20480))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20512))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20480))) /* Equivalent hex address = 0x342e5000UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Conv node=Gemm_682_gemm_279_2_conv_845 */
  Conv_integer_sw_info conv_integer114_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 32,
    .general.input.dim.tensor_c = 30,
    .general.input.dim.num_elem = 960,
    .general.input.stride.b = 960,
    .general.input.stride.h = 960,
    .general.input.stride.w = 30,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */,
    .general.input.format.is_signed = 1,
    /* "weights" tensor-related info: */
    .weights.dim.tensor_b = 30,
    .weights.dim.tensor_h = 1,
    .weights.dim.tensor_w = 1,
    .weights.dim.tensor_c = 30,
    .weights.dim.num_elem = 900,
    .weights.stride.b = 30,
    .weights.stride.h = 30,
    .weights.stride.w = 30,
    .weights.stride.c = 1,
    .weights.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 21024))) /* Equivalent hex address = 0x342e5220UL */,
    .weights.format.is_signed = 1,
    /* "bias" tensor-related info: */
    .bias.dim.tensor_b = 1,
    .bias.dim.tensor_h = 1,
    .bias.dim.tensor_w = 1,
    .bias.dim.tensor_c = 30,
    .bias.dim.num_elem = 30,
    .bias.stride.b = 120,
    .bias.stride.h = 120,
    .bias.stride.w = 4,
    .bias.stride.c = 4,
    .bias.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4560160))) /* Equivalent hex address = 0x71459520UL */,
    .bias.format.is_signed = 0,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567248))) /* Equivalent hex address = 0x7145b0d0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571472))) /* Equivalent hex address = 0x7145c150UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "ws" tensor-related info: */
    .ws.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567264))) /* Equivalent hex address = 0x7145b0e0UL */,
    .ws.format.is_signed = 0,
    .ws.dim.num_elem = 1,
    /* "wzp" tensor-related info: */
    .wzp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571488))) /* Equivalent hex address = 0x7145c160UL */,
    .wzp.format.is_signed = 1,
    .wzp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4567280))) /* Equivalent hex address = 0x7145b0f0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571504))) /* Equivalent hex address = 0x7145c170UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "scratch" tensor-related info: */
    .scratch.dim.tensor_b = 1,
    .scratch.dim.tensor_h = 1,
    .scratch.dim.tensor_w = 1,
    .scratch.dim.tensor_c = 123,
    .scratch.dim.num_elem = 123,
    .scratch.stride.b = 123,
    .scratch.stride.h = 123,
    .scratch.stride.w = 123,
    .scratch.stride.c = 1,
    .scratch.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20368))) /* Equivalent hex address = 0x342e4f90UL */,
    .scratch.format.is_signed = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 1,
    .general.output.dim.tensor_w = 32,
    .general.output.dim.tensor_c = 30,
    .general.output.dim.num_elem = 960,
    .general.output.stride.b = 960,
    .general.output.stride.h = 960,
    .general.output.stride.w = 30,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) /* Equivalent hex address = 0x342e9240UL */,
    .general.output.format.is_signed = 1,
    /* Node-specific Hyper-parameters: */
    .ngroup = 1,
    .pads = {0, 0, 0, 0},
    .strides = {1, 1},
    .dilations = {1, 1},
    .fwd_func = LL_SW_GENERIC_CONV,
    .general.type = LL_SW_CONV,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Gemm_682_gemm_279_2_conv_845 mapped on EmbedNets (INTEGER) as Conv | Category: Computational */
  ll_sw_forward_conv_integer(&conv_integer114_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20352))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20512))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 20352))) /* Equivalent hex address = 0x342e4f80UL */, 160);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 37440))) /* Equivalent hex address = 0x342e9240UL */, 960);

}


// Epoch Controller Blob (name='_ec_blob_Default_364') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_364') start function
static void _ec_blob_cache_start_func_364(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 34560))) /* Equivalent hex address = 0x342e8700UL */, 3840);

};


/* scheduling epoch=366  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_366(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42240))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 3840);

  /* Reset the stream switch */
  LL_Switch_Init(NULL, 0);

/* Unit= 27 [PROCESSOR 0] */
/* kind=Transpose node=Transpose_683 */
  static const uint32_t Transpose_683_tensor_shape_in_366_shape_0[] = { 1, 4, 30, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_683_tensor_shape_in_366[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 34560,
      .offset_end = 38400,
      .offset_limit = 38464,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_683_tensor_shape_in_366_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_683_tensor_axes_offsets_in_366_0[] = { 3840, 960, 32, 1 };
  static const uint32_t* Transpose_683_tensor_axes_offsets_in_366[] = {
    Transpose_683_tensor_axes_offsets_in_366_0
  };

  static const uint32_t Transpose_683_tensor_shape_out_366_shape_0[] = { 1, 30, 4, 32 };
  static const LL_LIB_TensorShape_TypeDef Transpose_683_tensor_shape_out_366[] = {
    {
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 38400,
      .offset_end = 42240,
      .offset_limit = 42304,
      .ndims = 4,
      .nbits = 8,
      .shape = Transpose_683_tensor_shape_out_366_shape_0,
      .batch = 1,
    }
  };

  static const uint32_t Transpose_683_tensor_axes_offsets_out_366_0[] = { 3840, 128, 32, 1 };
  static const uint32_t* Transpose_683_tensor_axes_offsets_out_366[] = {
    Transpose_683_tensor_axes_offsets_out_366_0
  };

  static const uint8_t Transpose_683_perm_to_use_array_in_366[] = { 0, 2, 1, 3 };
  static const uint8_t Transpose_683_target_pos_array_in_366[] = { 0, 2, 1, 3 };
  LL_ATON_LIB_DMA_Transpose(&Transpose_683_tensor_shape_in_366[0], Transpose_683_tensor_axes_offsets_in_366[0], &Transpose_683_tensor_shape_out_366[0], Transpose_683_tensor_axes_offsets_out_366[0], Transpose_683_target_pos_array_in_366, Transpose_683_perm_to_use_array_in_366, 0, 1);

  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42240))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_367') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_367') start function
static void _ec_blob_cache_start_func_367(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42304))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) /* Equivalent hex address = 0x342ea520UL */, 32);

};


/* scheduling epoch=375  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_375(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38496))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38528))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38496))) /* Equivalent hex address = 0x342e9660UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=DequantizeLinear node=DequantizeLinear_inserted_id3103 */
  Dequantizelinear_sw_info dequantizelinear115_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 42272))) /* Equivalent hex address = 0x342ea520UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569472))) /* Equivalent hex address = 0x7145b980UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573696))) /* Equivalent hex address = 0x7145ca00UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_DEQUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node DequantizeLinear_inserted_id3103 mapped on EmbedNets (INTEGER) as DequantizeLinear | Category: Format-Converter */
  ll_sw_forward_dequantizelinear(&dequantizelinear115_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38528))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 128);

}


/* scheduling epoch=376  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_376(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) /* Equivalent hex address = 0x342e0060UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Reciprocal node=Reciprocal_705 */
  Activ_sw_info activ116_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.input.format.is_signed = 0,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_RECIPROCAL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Reciprocal_705 mapped on EmbedNets (FLOAT) as Reciprocal | Category: Computational */
  ll_sw_forward_activ(&activ116_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 128);

}


/* scheduling epoch=377  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_377(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38432))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id3111 */
  Quantizelinear_sw_info quantizelinear117_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569824))) /* Equivalent hex address = 0x7145bae0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4574048))) /* Equivalent hex address = 0x7145cb60UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id3111 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear117_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38432))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */, 32);

}


/* scheduling epoch=378  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_378(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Mul node=Mul_706 */
  Eltwise_integer_sw_info eltwise_integer118_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 38400))) /* Equivalent hex address = 0x342e9600UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 1,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 128,
    .operand.stride.b = 128,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4557728))) /* Equivalent hex address = 0x71458ba0UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566144))) /* Equivalent hex address = 0x7145ac80UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570368))) /* Equivalent hex address = 0x7145bd00UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566160))) /* Equivalent hex address = 0x7145ac90UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570384))) /* Equivalent hex address = 0x7145bd10UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566176))) /* Equivalent hex address = 0x7145aca0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570400))) /* Equivalent hex address = 0x7145bd20UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 7680,
    .general.output.stride.h = 256,
    .general.output.stride.w = 2,
    .general.output.stride.c = 2,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHMUL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Mul_706 mapped on EmbedNets (INTEGER) as Mul | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer118_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 7680);

}


/* scheduling epoch=379  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_379(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id3112 */
  Quantizelinear_sw_info quantizelinear119_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569840))) /* Equivalent hex address = 0x7145baf0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4574064))) /* Equivalent hex address = 0x7145cb70UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id3112 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear119_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);

}


// Epoch Controller Blob (name='_ec_blob_Default_380') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_380') start function
static void _ec_blob_cache_start_func_380(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 30752))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) /* Equivalent hex address = 0x342e6920UL */, 3840);

};


/* scheduling epoch=382  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_382(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Sub node=Sub_712 */
  Eltwise_integer_sw_info eltwise_integer120_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 128,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 128,
    .general.input.stride.b = 128,
    .general.input.stride.h = 128,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4559264))) /* Equivalent hex address = 0x714591a0UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 30,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 3840,
    .operand.stride.b = 3840,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 26912))) /* Equivalent hex address = 0x342e6920UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566912))) /* Equivalent hex address = 0x7145af80UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571136))) /* Equivalent hex address = 0x7145c000UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566928))) /* Equivalent hex address = 0x7145af90UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571152))) /* Equivalent hex address = 0x7145c010UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566944))) /* Equivalent hex address = 0x7145afa0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571168))) /* Equivalent hex address = 0x7145c020UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 3840,
    .general.output.stride.h = 128,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHSUB,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Sub_712 mapped on EmbedNets (INTEGER) as Sub | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer120_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_383') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_383') start function
static void _ec_blob_cache_start_func_383(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);

};


/* scheduling epoch=395  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_395(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 96))) /* Equivalent hex address = 0x342e0060UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=DequantizeLinear node=DequantizeLinear_inserted_id3153 */
  Dequantizelinear_sw_info dequantizelinear121_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.input.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569488))) /* Equivalent hex address = 0x7145b990UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4573712))) /* Equivalent hex address = 0x7145ca10UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_DEQUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node DequantizeLinear_inserted_id3153 mapped on EmbedNets (INTEGER) as DequantizeLinear | Category: Format-Converter */
  ll_sw_forward_dequantizelinear(&dequantizelinear121_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 128))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */, 128);

}


/* scheduling epoch=396  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_396(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19328))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19328))) /* Equivalent hex address = 0x342e4b80UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Reciprocal node=Reciprocal_749 */
  Activ_sw_info activ122_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 0))) /* Equivalent hex address = 0x342e0000UL */,
    .general.input.format.is_signed = 0,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 120,
    .general.output.stride.h = 4,
    .general.output.stride.w = 4,
    .general.output.stride.c = 4,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.output.format.is_signed = 0,
    .general.type = LL_SW_RECIPROCAL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Reciprocal_749 mapped on EmbedNets (FLOAT) as Reciprocal | Category: Computational */
  ll_sw_forward_activ(&activ122_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19360))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */, 128);

}


/* scheduling epoch=397  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_397(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id3161 */
  Quantizelinear_sw_info quantizelinear123_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569856))) /* Equivalent hex address = 0x7145bb00UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4574080))) /* Equivalent hex address = 0x7145cb80UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id3161 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear123_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65344))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */, 32);

}


/* scheduling epoch=398  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_398(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Mul node=Mul_750 */
  Eltwise_integer_sw_info eltwise_integer124_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 30,
    .general.input.stride.h = 1,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 65312))) /* Equivalent hex address = 0x342eff20UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 1,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 128,
    .operand.stride.b = 128,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4557856))) /* Equivalent hex address = 0x71458c20UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566192))) /* Equivalent hex address = 0x7145acb0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570416))) /* Equivalent hex address = 0x7145bd30UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566208))) /* Equivalent hex address = 0x7145acc0UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570432))) /* Equivalent hex address = 0x7145bd40UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566224))) /* Equivalent hex address = 0x7145acd0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4570448))) /* Equivalent hex address = 0x7145bd50UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 7680,
    .general.output.stride.h = 256,
    .general.output.stride.w = 2,
    .general.output.stride.c = 2,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHMUL,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Mul_750 mapped on EmbedNets (INTEGER) as Mul | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer124_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 7680);

}


/* scheduling epoch=399  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_399(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation for unaligned buffer start or end address (only line) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);


/* Unit= 27 [PROCESSOR 0] */
/* kind=QuantizeLinear node=QuantizeLinear_inserted_id3162 */
  Quantizelinear_sw_info quantizelinear125_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 30,
    .general.input.dim.tensor_w = 1,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 30,
    .general.input.stride.b = 120,
    .general.input.stride.h = 4,
    .general.input.stride.w = 4,
    .general.input.stride.c = 4,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) /* Equivalent hex address = 0x342e4b20UL */,
    .general.input.format.is_signed = 0,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4569872))) /* Equivalent hex address = 0x7145bb10UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4574096))) /* Equivalent hex address = 0x7145cb90UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 1,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 30,
    .general.output.stride.b = 30,
    .general.output.stride.h = 1,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_QUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node QuantizeLinear_inserted_id3162 mapped on EmbedNets (INTEGER) as QuantizeLinear | Category: Format-Converter */
  ll_sw_forward_quantizelinear(&quantizelinear125_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19232))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) /* Equivalent hex address = 0x342e4b00UL */, 32);

}


// Epoch Controller Blob (name='_ec_blob_Default_400') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_400') start function
static void _ec_blob_cache_start_func_400(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */, 3840);

};


/* scheduling epoch=402  nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_402(const void *epoch_block)
{
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=Sub node=Sub_756 */
  Eltwise_integer_sw_info eltwise_integer126_sw_info = {
    /* "general.input" tensor-related info: */
    .general.input.dim.tensor_b = 1,
    .general.input.dim.tensor_h = 1,
    .general.input.dim.tensor_w = 128,
    .general.input.dim.tensor_c = 1,
    .general.input.dim.num_elem = 128,
    .general.input.stride.b = 128,
    .general.input.stride.h = 128,
    .general.input.stride.w = 1,
    .general.input.stride.c = 1,
    .general.input.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4559392))) /* Equivalent hex address = 0x71459220UL */,
    .general.input.format.is_signed = 1,
    /* "operand" tensor-related info: */
    .operand.dim.tensor_b = 1,
    .operand.dim.tensor_h = 30,
    .operand.dim.tensor_w = 128,
    .operand.dim.tensor_c = 1,
    .operand.dim.num_elem = 3840,
    .operand.stride.b = 3840,
    .operand.stride.h = 128,
    .operand.stride.w = 1,
    .operand.stride.c = 1,
    .operand.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 11520))) /* Equivalent hex address = 0x342e2d00UL */,
    .operand.format.is_signed = 1,
    /* "is" tensor-related info: */
    .is.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566960))) /* Equivalent hex address = 0x7145afb0UL */,
    .is.format.is_signed = 0,
    .is.dim.num_elem = 1,
    /* "izp" tensor-related info: */
    .izp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571184))) /* Equivalent hex address = 0x7145c030UL */,
    .izp.format.is_signed = 1,
    .izp.dim.num_elem = 1,
    /* "operand_s" tensor-related info: */
    .operand_s.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566976))) /* Equivalent hex address = 0x7145afc0UL */,
    .operand_s.format.is_signed = 0,
    .operand_s.dim.num_elem = 1,
    /* "operand_zp" tensor-related info: */
    .operand_zp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571200))) /* Equivalent hex address = 0x7145c040UL */,
    .operand_zp.format.is_signed = 1,
    .operand_zp.dim.num_elem = 1,
    /* "os" tensor-related info: */
    .os.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4566992))) /* Equivalent hex address = 0x7145afd0UL */,
    .os.format.is_signed = 0,
    .os.dim.num_elem = 1,
    /* "ozp" tensor-related info: */
    .ozp.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x71000000UL + 4571216))) /* Equivalent hex address = 0x7145c050UL */,
    .ozp.format.is_signed = 1,
    .ozp.dim.num_elem = 1,
    /* "general.output" tensor-related info: */
    .general.output.dim.tensor_b = 1,
    .general.output.dim.tensor_h = 30,
    .general.output.dim.tensor_w = 128,
    .general.output.dim.tensor_c = 1,
    .general.output.dim.num_elem = 3840,
    .general.output.stride.b = 3840,
    .general.output.stride.h = 128,
    .general.output.stride.w = 1,
    .general.output.stride.c = 1,
    .general.output.mem.start_offset = ((unsigned char *)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */,
    .general.output.format.is_signed = 1,
    .general.type = LL_SW_ARITHSUB,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Sub_756 mapped on EmbedNets (INTEGER) as Sub | Category: Computational */
  ll_sw_forward_eltwise_integer(&eltwise_integer126_sw_info);
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 1 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 19200))) */
  LL_ATON_Cache_MCU_Clean_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x342e0000UL + 15360))) /* Equivalent hex address = 0x342e3c00UL */, 3840);

}


// Epoch Controller Blob (name='_ec_blob_Default_403') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_Default_403') start function
static void _ec_blob_cache_start_func_403(const void *epoch_block) {
  LL_ATON_LIB_UNUSED(epoch_block);

  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 11 */
  /*     start: ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x34100000UL + 600000))) */
  /*     end:   ((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x34100000UL + 1200000))) */
  LL_ATON_Cache_MCU_Invalidate_Range(((uintptr_t)(ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x34100000UL + 600000))) /* Equivalent hex address = 0x341927c0UL */, 600000);

};


/* scheduling DONE                 ------------------------------------------------------------------- */

const EpochBlock_ItemTypeDef *LL_ATON_EpochBlockItems_Default(void) {

  static const EpochBlock_ItemTypeDef ll_atonn_rt_epoch_block_array[] = {
    {
      .start_epoch_block = _ec_blob_cache_start_func_1,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_1),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_1 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 1,
      .last_epoch_num = 6,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_7,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 7,
      .last_epoch_num = 7,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_8,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_8),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_8 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 8,
      .last_epoch_num = 8,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_9,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 9,
      .last_epoch_num = 9,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_10,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_10),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_10 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 10,
      .last_epoch_num = 12,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_13,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 13,
      .last_epoch_num = 13,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_14,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 14,
      .last_epoch_num = 14,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_15,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 15,
      .last_epoch_num = 15,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_16,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 16,
      .last_epoch_num = 16,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_17,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_17),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_17 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 17,
      .last_epoch_num = 20,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_21,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 21,
      .last_epoch_num = 21,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_22),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_22 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 22,
      .last_epoch_num = 22,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_23,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 23,
      .last_epoch_num = 23,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_24),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_24 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 24,
      .last_epoch_num = 24,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_25,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 25,
      .last_epoch_num = 25,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_26,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 26,
      .last_epoch_num = 26,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_27,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 27,
      .last_epoch_num = 27,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_28,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 28,
      .last_epoch_num = 28,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_29,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_29),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_29 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 29,
      .last_epoch_num = 30,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_31,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 31,
      .last_epoch_num = 31,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_32,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_32),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_32 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 32,
      .last_epoch_num = 39,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_40,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 40,
      .last_epoch_num = 40,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_41,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 41,
      .last_epoch_num = 41,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_42,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 42,
      .last_epoch_num = 42,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_43,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 43,
      .last_epoch_num = 43,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_44,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 44,
      .last_epoch_num = 44,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_45,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_45),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_45 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 45,
      .last_epoch_num = 46,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_47,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 47,
      .last_epoch_num = 47,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_48,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_48),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_48 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 48,
      .last_epoch_num = 59,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_60,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 60,
      .last_epoch_num = 60,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_61,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 61,
      .last_epoch_num = 61,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_62,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 62,
      .last_epoch_num = 62,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_63,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 63,
      .last_epoch_num = 63,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_64,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 64,
      .last_epoch_num = 64,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_65,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_65),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_65 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 65,
      .last_epoch_num = 66,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_67,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 67,
      .last_epoch_num = 67,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_68,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_68),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_68 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 68,
      .last_epoch_num = 73,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_74,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 74,
      .last_epoch_num = 74,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_75,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_75),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_75 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 75,
      .last_epoch_num = 75,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_76,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 76,
      .last_epoch_num = 76,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_77,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_77),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_77 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 77,
      .last_epoch_num = 79,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_80,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 80,
      .last_epoch_num = 80,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_81,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 81,
      .last_epoch_num = 81,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_82,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 82,
      .last_epoch_num = 82,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_83,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 83,
      .last_epoch_num = 83,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_84,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_84),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_84 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 84,
      .last_epoch_num = 87,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_88,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 88,
      .last_epoch_num = 88,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_89),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_89 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 89,
      .last_epoch_num = 89,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_90,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 90,
      .last_epoch_num = 90,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_91),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_91 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 91,
      .last_epoch_num = 91,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_92,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 92,
      .last_epoch_num = 92,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_93,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 93,
      .last_epoch_num = 93,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_94,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 94,
      .last_epoch_num = 94,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_95,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 95,
      .last_epoch_num = 95,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_96,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_96),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_96 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 96,
      .last_epoch_num = 97,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_98,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 98,
      .last_epoch_num = 98,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_99,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_99),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_99 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 99,
      .last_epoch_num = 106,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_107,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 107,
      .last_epoch_num = 107,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_108,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 108,
      .last_epoch_num = 108,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_109,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 109,
      .last_epoch_num = 109,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_110,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 110,
      .last_epoch_num = 110,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_111,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 111,
      .last_epoch_num = 111,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_112,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_112),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_112 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 112,
      .last_epoch_num = 113,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_114,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 114,
      .last_epoch_num = 114,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_115,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_115),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_115 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 115,
      .last_epoch_num = 126,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_127,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 127,
      .last_epoch_num = 127,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_128,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 128,
      .last_epoch_num = 128,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_129,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 129,
      .last_epoch_num = 129,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_130,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 130,
      .last_epoch_num = 130,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_131,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 131,
      .last_epoch_num = 131,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_132,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_132),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_132 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 132,
      .last_epoch_num = 133,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_134,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 134,
      .last_epoch_num = 134,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_135,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_135),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_135 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 135,
      .last_epoch_num = 140,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_141,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 141,
      .last_epoch_num = 141,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_142,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_142),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_142 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 142,
      .last_epoch_num = 142,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_143,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 143,
      .last_epoch_num = 143,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_144,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_144),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_144 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 144,
      .last_epoch_num = 146,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_147,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 147,
      .last_epoch_num = 147,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_148,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 148,
      .last_epoch_num = 148,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_149,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 149,
      .last_epoch_num = 149,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_150,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 150,
      .last_epoch_num = 150,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_151,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_151),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_151 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 151,
      .last_epoch_num = 154,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_155,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 155,
      .last_epoch_num = 155,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_156),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_156 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 156,
      .last_epoch_num = 156,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_157,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 157,
      .last_epoch_num = 157,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_158),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_158 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 158,
      .last_epoch_num = 158,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_159,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 159,
      .last_epoch_num = 159,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_160,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 160,
      .last_epoch_num = 160,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_161,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 161,
      .last_epoch_num = 161,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_162,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 162,
      .last_epoch_num = 162,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_163,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_163),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_163 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 163,
      .last_epoch_num = 164,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_165,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 165,
      .last_epoch_num = 165,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_166,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_166),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_166 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 166,
      .last_epoch_num = 173,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_174,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 174,
      .last_epoch_num = 174,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_175,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 175,
      .last_epoch_num = 175,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_176,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 176,
      .last_epoch_num = 176,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_177,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 177,
      .last_epoch_num = 177,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_178,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 178,
      .last_epoch_num = 178,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_179,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_179),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_179 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 179,
      .last_epoch_num = 180,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_181,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 181,
      .last_epoch_num = 181,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_182,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_182),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_182 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 182,
      .last_epoch_num = 193,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_194,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 194,
      .last_epoch_num = 194,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_195,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 195,
      .last_epoch_num = 195,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_196,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 196,
      .last_epoch_num = 196,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_197,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 197,
      .last_epoch_num = 197,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_198,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 198,
      .last_epoch_num = 198,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_199,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_199),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_199 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 199,
      .last_epoch_num = 200,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_201,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 201,
      .last_epoch_num = 201,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_202,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_202),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_202 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 202,
      .last_epoch_num = 207,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_208,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 208,
      .last_epoch_num = 208,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_209,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_209),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_209 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 209,
      .last_epoch_num = 209,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_210,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 210,
      .last_epoch_num = 210,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_211,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_211),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_211 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 211,
      .last_epoch_num = 213,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_214,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 214,
      .last_epoch_num = 214,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_215,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 215,
      .last_epoch_num = 215,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_216,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 216,
      .last_epoch_num = 216,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_217,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 217,
      .last_epoch_num = 217,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_218,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_218),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_218 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 218,
      .last_epoch_num = 221,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_222,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 222,
      .last_epoch_num = 222,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_223),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_223 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 223,
      .last_epoch_num = 223,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_224,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 224,
      .last_epoch_num = 224,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_225),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_225 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 225,
      .last_epoch_num = 225,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_226,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 226,
      .last_epoch_num = 226,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_227,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 227,
      .last_epoch_num = 227,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_228,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 228,
      .last_epoch_num = 228,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_229,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 229,
      .last_epoch_num = 229,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_230,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_230),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_230 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 230,
      .last_epoch_num = 231,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_232,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 232,
      .last_epoch_num = 232,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_233,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_233),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_233 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 233,
      .last_epoch_num = 240,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_241,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 241,
      .last_epoch_num = 241,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_242,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 242,
      .last_epoch_num = 242,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_243,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 243,
      .last_epoch_num = 243,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_244,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 244,
      .last_epoch_num = 244,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_245,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 245,
      .last_epoch_num = 245,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_246,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_246),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_246 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 246,
      .last_epoch_num = 247,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_248,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 248,
      .last_epoch_num = 248,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_249,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_249),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_249 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 249,
      .last_epoch_num = 260,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_261,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 261,
      .last_epoch_num = 261,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_262,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 262,
      .last_epoch_num = 262,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_263,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 263,
      .last_epoch_num = 263,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_264,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 264,
      .last_epoch_num = 264,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_265,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 265,
      .last_epoch_num = 265,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_266,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_266),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_266 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 266,
      .last_epoch_num = 267,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_268,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 268,
      .last_epoch_num = 268,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_269,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_269),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_269 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 269,
      .last_epoch_num = 274,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_275,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 275,
      .last_epoch_num = 275,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_276,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_276),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_276 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 276,
      .last_epoch_num = 276,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_277,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 277,
      .last_epoch_num = 277,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_278,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_278),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_278 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 278,
      .last_epoch_num = 280,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_281,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 281,
      .last_epoch_num = 281,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_282,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 282,
      .last_epoch_num = 282,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_283,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 283,
      .last_epoch_num = 283,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_284,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 284,
      .last_epoch_num = 284,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_285,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_285),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_285 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 285,
      .last_epoch_num = 288,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_289,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 289,
      .last_epoch_num = 289,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_290),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_290 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 290,
      .last_epoch_num = 290,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_291,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 291,
      .last_epoch_num = 291,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_292),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_292 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 292,
      .last_epoch_num = 292,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_293,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 293,
      .last_epoch_num = 293,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_294,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 294,
      .last_epoch_num = 294,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_295,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 295,
      .last_epoch_num = 295,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_296,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 296,
      .last_epoch_num = 296,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_297,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_297),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_297 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 297,
      .last_epoch_num = 298,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_299,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 299,
      .last_epoch_num = 299,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_300,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_300),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_300 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 300,
      .last_epoch_num = 307,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_308,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 308,
      .last_epoch_num = 308,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_309,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 309,
      .last_epoch_num = 309,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_310,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 310,
      .last_epoch_num = 310,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_311,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 311,
      .last_epoch_num = 311,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_312,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 312,
      .last_epoch_num = 312,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_313,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_313),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_313 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 313,
      .last_epoch_num = 314,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_315,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 315,
      .last_epoch_num = 315,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_316,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_316),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_316 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 316,
      .last_epoch_num = 327,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_328,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 328,
      .last_epoch_num = 328,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_329,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 329,
      .last_epoch_num = 329,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_330,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 330,
      .last_epoch_num = 330,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_331,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 331,
      .last_epoch_num = 331,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_332,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 332,
      .last_epoch_num = 332,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_333,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_333),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_333 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 333,
      .last_epoch_num = 334,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_335,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 335,
      .last_epoch_num = 335,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_336,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_336),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_336 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 336,
      .last_epoch_num = 341,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_342,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 342,
      .last_epoch_num = 342,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_343,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_343),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_343 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 343,
      .last_epoch_num = 343,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_344,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 344,
      .last_epoch_num = 344,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_345,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_345),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_345 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 345,
      .last_epoch_num = 347,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_348,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 348,
      .last_epoch_num = 348,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_349,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 349,
      .last_epoch_num = 349,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_350,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 350,
      .last_epoch_num = 350,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_351,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 351,
      .last_epoch_num = 351,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_352,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_352),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_352 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 352,
      .last_epoch_num = 355,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_356,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 356,
      .last_epoch_num = 356,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_357),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_357 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 357,
      .last_epoch_num = 357,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_358,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 358,
      .last_epoch_num = 358,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_359),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_359 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 359,
      .last_epoch_num = 359,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_360,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 360,
      .last_epoch_num = 360,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_361,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 361,
      .last_epoch_num = 361,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_362,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 362,
      .last_epoch_num = 362,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_363,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 363,
      .last_epoch_num = 363,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_364,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_364),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_364 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 364,
      .last_epoch_num = 365,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_366,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_hybrid,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 366,
      .last_epoch_num = 366,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_367,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_367),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_367 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 367,
      .last_epoch_num = 374,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_375,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 375,
      .last_epoch_num = 375,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_376,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 376,
      .last_epoch_num = 376,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_377,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 377,
      .last_epoch_num = 377,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_378,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 378,
      .last_epoch_num = 378,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_379,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 379,
      .last_epoch_num = 379,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_380,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_380),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_380 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 380,
      .last_epoch_num = 381,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_382,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 382,
      .last_epoch_num = 382,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_383,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_383),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_383 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 383,
      .last_epoch_num = 394,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_395,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 395,
      .last_epoch_num = 395,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_396,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 396,
      .last_epoch_num = 396,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_397,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 397,
      .last_epoch_num = 397,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_398,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 398,
      .last_epoch_num = 398,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_399,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 399,
      .last_epoch_num = 399,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_400,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_400),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_400 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 400,
      .last_epoch_num = 401,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = NULL,
      .end_epoch_block = LL_ATON_End_EpochBlock_402,
      .wait_mask = 0x00000000,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_pure_sw,
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 402,
      .last_epoch_num = 402,
      .in_streng_mask = 0x00000000,
      .out_streng_mask = 0x00000000,
      .estimated_npu_cycles = 0,
      .estimated_tot_cycles = 0,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .start_epoch_block = _ec_blob_cache_start_func_403,
      .end_epoch_block = NULL,
      .blob_address = (uintptr_t)(_ec_blob_Default_403),
      .wait_mask = 0,
      .flags = EpochBlock_Flags_epoch_start | EpochBlock_Flags_epoch_end | EpochBlock_Flags_blob | EpochBlock_Flags_pure_hw | (LL_ATON_EC_MustDecryptBlob_Default__ec_blob_Default_403 ? EpochBlock_Flags_blob_encrypted : EpochBlock_Flags_NONE),
#ifdef LL_ATON_EB_DBG_INFO
      .epoch_num = 403,
      .last_epoch_num = 408,
#endif // LL_ATON_EB_DBG_INFO
    },
    {
      .flags = EpochBlock_Flags_last_eb,
    },
  };


  return ll_atonn_rt_epoch_block_array;
}

const LL_Buffer_InfoTypeDef *LL_ATON_Input_Buffers_Info_Default(void)
{
  static const uint32_t buff_info__shape_1_30_128[] = { 1, 30, 128, 1 };
  static const uint32_t buff_info__mem_shape_F_1_30_128[] = { 1, 30, 128 };
  static const float buff_info_Input_65_out_0_quant_scale[] = { 0.00141439691651613 };
  static const int16_t buff_info_Input_65_out_0_quant_offset[] = { -29 };
#if LL_ATON_DBG_BUFFER_INFO_EXCLUDED == 0
  static const float buff_info_Add_70_param1_quant_scale[] = { 0.00784309860318899 };
  static const int16_t buff_info_Add_70_param1_quant_offset[] = { -1 };
  static const uint32_t buff_info__shape_1_1_128[] = { 1, 1, 128, 1 };
  static const uint32_t buff_info__mem_shape_F_1_1_128[] = { 1, 1, 128 };
  static const float buff_info_Mul_131_param1_quant_scale[] = { 0.00420106528326869 };
  static const int16_t buff_info_Mul_131_param1_quant_offset[] = { -128 };
  static const float buff_info_Sub_137_param0_quant_scale[] = { 0.000328579189954326 };
  static const int16_t buff_info_Sub_137_param0_quant_offset[] = { -6 };
  static const uint32_t buff_info__shape_1_1_1024[] = { 1, 1, 1024, 1 };
  static const uint32_t buff_info__mem_shape_F_1_1_1024[] = { 1, 1, 1024 };
  static const float buff_info_Add_149_param1_quant_scale[] = { 0.000424545811256394 };
  static const int16_t buff_info_Add_149_param1_quant_offset[] = { -32 };
  static const float buff_info_Mul_175_param1_quant_scale[] = { 0.00408044410869479 };
  static const int16_t buff_info_Mul_175_param1_quant_offset[] = { -128 };
  static const float buff_info_Sub_181_param0_quant_scale[] = { 0.000300427374895662 };
  static const int16_t buff_info_Sub_181_param0_quant_offset[] = { -5 };
  static const float buff_info_Mul_246_param1_quant_scale[] = { 0.00409155897796154 };
  static const int16_t buff_info_Mul_246_param1_quant_offset[] = { -128 };
  static const float buff_info_Sub_252_param0_quant_scale[] = { 0.000306755042402074 };
  static const int16_t buff_info_Sub_252_param0_quant_offset[] = { 1 };
  static const float buff_info_Add_264_param1_quant_scale[] = { 0.000407897430704907 };
  static const int16_t buff_info_Add_264_param1_quant_offset[] = { 1 };
  static const float buff_info_Mul_290_param1_quant_scale[] = { 0.0040949760004878 };
  static const int16_t buff_info_Mul_290_param1_quant_offset[] = { -128 };
  static const float buff_info_Sub_296_param0_quant_scale[] = { 0.000328306457959116 };
  static const int16_t buff_info_Sub_296_param0_quant_offset[] = { 3 };
  static const float buff_info_Mul_361_param1_quant_scale[] = { 0.0041348859667778 };
  static const int16_t buff_info_Mul_361_param1_quant_offset[] = { -128 };
  static const float buff_info_Sub_367_param0_quant_scale[] = { 0.000322546780807897 };
  static const int16_t buff_info_Sub_367_param0_quant_offset[] = { 2 };
  static const float buff_info_Add_379_param1_quant_scale[] = { 0.000375773612176999 };
  static const int16_t buff_info_Add_379_param1_quant_offset[] = { 7 };
  static const float buff_info_Mul_405_param1_quant_scale[] = { 0.0041731889359653 };
  static const int16_t buff_info_Mul_405_param1_quant_offset[] = { -128 };
  static const float buff_info_Sub_411_param0_quant_scale[] = { 0.000491702812723815 };
  static const int16_t buff_info_Sub_411_param0_quant_offset[] = { -2 };
  static const float buff_info_Mul_476_param1_quant_scale[] = { 0.00430585350841284 };
  static const int16_t buff_info_Mul_476_param1_quant_offset[] = { -128 };
  static const float buff_info_Sub_482_param0_quant_scale[] = { 0.000678118143696338 };
  static const int16_t buff_info_Sub_482_param0_quant_offset[] = { 10 };
  static const float buff_info_Add_494_param1_quant_scale[] = { 0.000890567316673696 };
  static const int16_t buff_info_Add_494_param1_quant_offset[] = { -52 };
  static const float buff_info_Mul_520_param1_quant_scale[] = { 0.00479292823001742 };
  static const int16_t buff_info_Mul_520_param1_quant_offset[] = { -128 };
  static const float buff_info_Sub_526_param0_quant_scale[] = { 0.00153290829621255 };
  static const int16_t buff_info_Sub_526_param0_quant_offset[] = { -4 };
  static const float buff_info_Mul_591_param1_quant_scale[] = { 0.00470432220026851 };
  static const int16_t buff_info_Mul_591_param1_quant_offset[] = { -128 };
  static const float buff_info_Sub_597_param0_quant_scale[] = { 0.00125068798661232 };
  static const int16_t buff_info_Sub_597_param0_quant_offset[] = { 5 };
  static const float buff_info_Add_609_param1_quant_scale[] = { 0.0018445064779371 };
  static const int16_t buff_info_Add_609_param1_quant_offset[] = { -34 };
  static const float buff_info_Mul_635_param1_quant_scale[] = { 0.00537591287866235 };
  static const int16_t buff_info_Mul_635_param1_quant_offset[] = { -128 };
  static const float buff_info_Sub_641_param0_quant_scale[] = { 0.00220680423080921 };
  static const int16_t buff_info_Sub_641_param0_quant_offset[] = { -16 };
  static const float buff_info_Mul_706_param1_quant_scale[] = { 0.00689016981050372 };
  static const int16_t buff_info_Mul_706_param1_quant_offset[] = { -128 };
  static const float buff_info_Sub_712_param0_quant_scale[] = { 0.00426686136052012 };
  static const int16_t buff_info_Sub_712_param0_quant_offset[] = { -71 };
  static const float buff_info_Add_724_param1_quant_scale[] = { 0.00333316507749259 };
  static const int16_t buff_info_Add_724_param1_quant_offset[] = { -82 };
  static const float buff_info_Mul_750_param1_quant_scale[] = { 0.00407990906387568 };
  static const int16_t buff_info_Mul_750_param1_quant_offset[] = { -128 };
  static const float buff_info_Sub_756_param0_quant_scale[] = { 0.00422185519710183 };
  static const int16_t buff_info_Sub_756_param0_quant_offset[] = { 37 };
  static const uint32_t buff_info__shape_1_1_20000[] = { 1, 1, 20000, 1 };
  static const uint32_t buff_info__mem_shape_F_1_1_20000[] = { 1, 1, 20000 };
  static const float buff_info_Add_768_param1_quant_scale[] = { 0.00788620952516794 };
  static const int16_t buff_info_Add_768_param1_quant_offset[] = { 20 };
  static const uint32_t buff_info__shape_128_128_1_1[] = { 128, 1, 1, 128 };
  static const uint32_t buff_info__mem_shape_M16_128_128_1_1[] = { 128, 8, 1, 1, 16 };
  static const float buff_info_Gemm_77_weights_transposed_291_quant_scale[] = { 0.00195170938968658 };
  static const int16_t buff_info_Gemm_77_weights_transposed_291_quant_offset[] = { 0 };
  static const float buff_info_Gemm_85_weights_transposed_298_quant_scale[] = { 0.00166635506320745 };
  static const int16_t buff_info_Gemm_85_weights_transposed_298_quant_offset[] = { 0 };
  static const float buff_info_Gemm_93_weights_transposed_305_quant_scale[] = { 0.00166899641044438 };
  static const int16_t buff_info_Gemm_93_weights_transposed_305_quant_offset[] = { 0 };
  static const float buff_info_Gemm_111_weights_transposed_368_quant_scale[] = { 0.00191044702660292 };
  static const int16_t buff_info_Gemm_111_weights_transposed_368_quant_offset[] = { 0 };
  static const uint32_t buff_info__shape_1024_128_1_1[] = { 1024, 1, 1, 128 };
  static const uint32_t buff_info__mem_shape_M16_1024_128_1_1[] = { 1024, 8, 1, 1, 16 };
  static const float buff_info_Gemm_146_weights_transposed_375_quant_scale[] = { 0.00211830297484994 };
  static const int16_t buff_info_Gemm_146_weights_transposed_375_quant_offset[] = { 0 };
  static const uint32_t buff_info__shape_128_1024_1_1[] = { 128, 1, 1, 1024 };
  static const uint32_t buff_info__mem_shape_M128_128_1024_1_1[] = { 128, 8, 1, 1, 128 };
  static const float buff_info_Gemm_155_weights_transposed_382_quant_scale[] = { 0.00168555788695812 };
  static const int16_t buff_info_Gemm_155_weights_transposed_382_quant_offset[] = { 0 };
  static const float buff_info_Gemm_192_weights_transposed_389_quant_scale[] = { 0.00156124029308558 };
  static const int16_t buff_info_Gemm_192_weights_transposed_389_quant_offset[] = { 0 };
  static const float buff_info_Gemm_200_weights_transposed_396_quant_scale[] = { 0.00155744177754968 };
  static const int16_t buff_info_Gemm_200_weights_transposed_396_quant_offset[] = { 0 };
  static const float buff_info_Gemm_208_weights_transposed_403_quant_scale[] = { 0.00162291491869837 };
  static const int16_t buff_info_Gemm_208_weights_transposed_403_quant_offset[] = { 0 };
  static const float buff_info_Gemm_226_weights_transposed_466_quant_scale[] = { 0.00158965901937336 };
  static const int16_t buff_info_Gemm_226_weights_transposed_466_quant_offset[] = { 0 };
  static const float buff_info_Gemm_261_weights_transposed_473_quant_scale[] = { 0.00183667859528214 };
  static const int16_t buff_info_Gemm_261_weights_transposed_473_quant_offset[] = { 0 };
  static const float buff_info_Gemm_270_weights_transposed_480_quant_scale[] = { 0.00142437277827412 };
  static const int16_t buff_info_Gemm_270_weights_transposed_480_quant_offset[] = { 0 };
  static const float buff_info_Gemm_307_weights_transposed_487_quant_scale[] = { 0.00166978256311268 };
  static const int16_t buff_info_Gemm_307_weights_transposed_487_quant_offset[] = { 0 };
  static const float buff_info_Gemm_315_weights_transposed_494_quant_scale[] = { 0.00147329876199365 };
  static const int16_t buff_info_Gemm_315_weights_transposed_494_quant_offset[] = { 0 };
  static const float buff_info_Gemm_323_weights_transposed_501_quant_scale[] = { 0.00147789681795985 };
  static const int16_t buff_info_Gemm_323_weights_transposed_501_quant_offset[] = { 0 };
  static const float buff_info_Gemm_341_weights_transposed_564_quant_scale[] = { 0.00173470028676093 };
  static const int16_t buff_info_Gemm_341_weights_transposed_564_quant_offset[] = { 0 };
  static const float buff_info_Gemm_376_weights_transposed_571_quant_scale[] = { 0.0013411397812888 };
  static const int16_t buff_info_Gemm_376_weights_transposed_571_quant_offset[] = { 0 };
  static const float buff_info_Gemm_385_weights_transposed_578_quant_scale[] = { 0.00129721115808934 };
  static const int16_t buff_info_Gemm_385_weights_transposed_578_quant_offset[] = { 0 };
  static const float buff_info_Gemm_422_weights_transposed_585_quant_scale[] = { 0.001900585135445 };
  static const int16_t buff_info_Gemm_422_weights_transposed_585_quant_offset[] = { 0 };
  static const float buff_info_Gemm_430_weights_transposed_592_quant_scale[] = { 0.00131271628197283 };
  static const int16_t buff_info_Gemm_430_weights_transposed_592_quant_offset[] = { 0 };
  static const float buff_info_Gemm_438_weights_transposed_599_quant_scale[] = { 0.00128755369223654 };
  static const int16_t buff_info_Gemm_438_weights_transposed_599_quant_offset[] = { 0 };
  static const float buff_info_Gemm_456_weights_transposed_662_quant_scale[] = { 0.00181495735887438 };
  static const int16_t buff_info_Gemm_456_weights_transposed_662_quant_offset[] = { 0 };
  static const float buff_info_Gemm_491_weights_transposed_669_quant_scale[] = { 0.00213531916961074 };
  static const int16_t buff_info_Gemm_491_weights_transposed_669_quant_offset[] = { 0 };
  static const float buff_info_Gemm_500_weights_transposed_676_quant_scale[] = { 0.00237797480076551 };
  static const int16_t buff_info_Gemm_500_weights_transposed_676_quant_offset[] = { 0 };
  static const float buff_info_Gemm_537_weights_transposed_683_quant_scale[] = { 0.00275604473426938 };
  static const int16_t buff_info_Gemm_537_weights_transposed_683_quant_offset[] = { 0 };
  static const float buff_info_Gemm_545_weights_transposed_690_quant_scale[] = { 0.0012492504902184 };
  static const int16_t buff_info_Gemm_545_weights_transposed_690_quant_offset[] = { 0 };
  static const float buff_info_Gemm_553_weights_transposed_697_quant_scale[] = { 0.00124921533279121 };
  static const int16_t buff_info_Gemm_553_weights_transposed_697_quant_offset[] = { 0 };
  static const float buff_info_Gemm_571_weights_transposed_760_quant_scale[] = { 0.00318736350163817 };
  static const int16_t buff_info_Gemm_571_weights_transposed_760_quant_offset[] = { 0 };
  static const float buff_info_Gemm_606_weights_transposed_767_quant_scale[] = { 0.00364302797242999 };
  static const int16_t buff_info_Gemm_606_weights_transposed_767_quant_offset[] = { 0 };
  static const float buff_info_Gemm_615_weights_transposed_774_quant_scale[] = { 0.00550159020349383 };
  static const int16_t buff_info_Gemm_615_weights_transposed_774_quant_offset[] = { 0 };
  static const float buff_info_Gemm_652_weights_transposed_781_quant_scale[] = { 0.00426701735705137 };
  static const int16_t buff_info_Gemm_652_weights_transposed_781_quant_offset[] = { 0 };
  static const float buff_info_Gemm_660_weights_transposed_788_quant_scale[] = { 0.00124684651382267 };
  static const int16_t buff_info_Gemm_660_weights_transposed_788_quant_offset[] = { 0 };
  static const float buff_info_Gemm_668_weights_transposed_795_quant_scale[] = { 0.0012469133362174 };
  static const int16_t buff_info_Gemm_668_weights_transposed_795_quant_offset[] = { 0 };
  static const float buff_info_Gemm_686_weights_transposed_858_quant_scale[] = { 0.00725297536700964 };
  static const int16_t buff_info_Gemm_686_weights_transposed_858_quant_offset[] = { 0 };
  static const float buff_info_Gemm_721_weights_transposed_865_quant_scale[] = { 0.00730839837342501 };
  static const int16_t buff_info_Gemm_721_weights_transposed_865_quant_offset[] = { 0 };
  static const float buff_info_Gemm_730_weights_transposed_872_quant_scale[] = { 0.00925284717231989 };
  static const int16_t buff_info_Gemm_730_weights_transposed_872_quant_offset[] = { 0 };
  static const uint32_t buff_info__shape_20000_128_1_1[] = { 20000, 1, 1, 128 };
  static const uint32_t buff_info__mem_shape_M16_20000_128_1_1[] = { 20000, 8, 1, 1, 16 };
  static const float buff_info_Gemm_765_weights_transposed_879_quant_scale[] = { 0.0175881311297417 };
  static const int16_t buff_info_Gemm_765_weights_transposed_879_quant_offset[] = { 0 };
  static const uint32_t buff_info__shape_30[] = { 1, 1, 30, 1 };
  static const uint32_t buff_info__mem_shape_U_30[] = { 30 };
  static const uint32_t buff_info__shape_1[] = { 1, 1, 1, 1 };
  static const uint32_t buff_info__mem_shape_U_1[] = { 1 };
#endif // LL_ATON_DBG_BUFFER_INFO_EXCLUDED == 0
  static const LL_Buffer_InfoTypeDef buff_info[] = {
    {
      .name = "Input_65_out_0",
      .addr_base = {(unsigned char *)(0x342e0000UL) /* Equivalent hex address = 0x342e0000UL */},
      .offset_start = 0,
      .offset_end = 3840,
      .offset_limit = 3904,
      .is_user_allocated = 0,
      .is_param = 0,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_30_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_30_128,
      .per_channel = 0,
      .scale = buff_info_Input_65_out_0_quant_scale,
      .offset = buff_info_Input_65_out_0_quant_offset,
    },
#if LL_ATON_DBG_BUFFER_INFO_EXCLUDED == 0
    {
      .name = "Add_70_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4546464,
      .offset_end = 4550304,
      .offset_limit = 4550368,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_30_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_30_128,
      .per_channel = 0,
      .scale = buff_info_Add_70_param1_quant_scale,
      .offset = buff_info_Add_70_param1_quant_offset,
    },
    {
      .name = "Mul_131_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4556448,
      .offset_end = 4556576,
      .offset_limit = 4556640,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Mul_131_param1_quant_scale,
      .offset = buff_info_Mul_131_param1_quant_offset,
    },
    {
      .name = "Sub_137_param0",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4557984,
      .offset_end = 4558112,
      .offset_limit = 4558176,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Sub_137_param0_quant_scale,
      .offset = buff_info_Sub_137_param0_quant_offset,
    },
    {
      .name = "Add_149_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4550304,
      .offset_end = 4551328,
      .offset_limit = 4551392,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_1024,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_1024,
      .per_channel = 0,
      .scale = buff_info_Add_149_param1_quant_scale,
      .offset = buff_info_Add_149_param1_quant_offset,
    },
    {
      .name = "Mul_175_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4556576,
      .offset_end = 4556704,
      .offset_limit = 4556768,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Mul_175_param1_quant_scale,
      .offset = buff_info_Mul_175_param1_quant_offset,
    },
    {
      .name = "Sub_181_param0",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4558112,
      .offset_end = 4558240,
      .offset_limit = 4558304,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Sub_181_param0_quant_scale,
      .offset = buff_info_Sub_181_param0_quant_offset,
    },
    {
      .name = "Mul_246_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4556704,
      .offset_end = 4556832,
      .offset_limit = 4556896,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Mul_246_param1_quant_scale,
      .offset = buff_info_Mul_246_param1_quant_offset,
    },
    {
      .name = "Sub_252_param0",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4558240,
      .offset_end = 4558368,
      .offset_limit = 4558432,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Sub_252_param0_quant_scale,
      .offset = buff_info_Sub_252_param0_quant_offset,
    },
    {
      .name = "Add_264_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4551328,
      .offset_end = 4552352,
      .offset_limit = 4552416,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_1024,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_1024,
      .per_channel = 0,
      .scale = buff_info_Add_264_param1_quant_scale,
      .offset = buff_info_Add_264_param1_quant_offset,
    },
    {
      .name = "Mul_290_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4556832,
      .offset_end = 4556960,
      .offset_limit = 4557024,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Mul_290_param1_quant_scale,
      .offset = buff_info_Mul_290_param1_quant_offset,
    },
    {
      .name = "Sub_296_param0",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4558368,
      .offset_end = 4558496,
      .offset_limit = 4558560,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Sub_296_param0_quant_scale,
      .offset = buff_info_Sub_296_param0_quant_offset,
    },
    {
      .name = "Mul_361_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4556960,
      .offset_end = 4557088,
      .offset_limit = 4557152,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Mul_361_param1_quant_scale,
      .offset = buff_info_Mul_361_param1_quant_offset,
    },
    {
      .name = "Sub_367_param0",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4558496,
      .offset_end = 4558624,
      .offset_limit = 4558688,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Sub_367_param0_quant_scale,
      .offset = buff_info_Sub_367_param0_quant_offset,
    },
    {
      .name = "Add_379_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4552352,
      .offset_end = 4553376,
      .offset_limit = 4553440,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_1024,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_1024,
      .per_channel = 0,
      .scale = buff_info_Add_379_param1_quant_scale,
      .offset = buff_info_Add_379_param1_quant_offset,
    },
    {
      .name = "Mul_405_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4557088,
      .offset_end = 4557216,
      .offset_limit = 4557280,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Mul_405_param1_quant_scale,
      .offset = buff_info_Mul_405_param1_quant_offset,
    },
    {
      .name = "Sub_411_param0",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4558624,
      .offset_end = 4558752,
      .offset_limit = 4558816,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Sub_411_param0_quant_scale,
      .offset = buff_info_Sub_411_param0_quant_offset,
    },
    {
      .name = "Mul_476_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4557216,
      .offset_end = 4557344,
      .offset_limit = 4557408,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Mul_476_param1_quant_scale,
      .offset = buff_info_Mul_476_param1_quant_offset,
    },
    {
      .name = "Sub_482_param0",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4558752,
      .offset_end = 4558880,
      .offset_limit = 4558944,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Sub_482_param0_quant_scale,
      .offset = buff_info_Sub_482_param0_quant_offset,
    },
    {
      .name = "Add_494_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4553376,
      .offset_end = 4554400,
      .offset_limit = 4554464,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_1024,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_1024,
      .per_channel = 0,
      .scale = buff_info_Add_494_param1_quant_scale,
      .offset = buff_info_Add_494_param1_quant_offset,
    },
    {
      .name = "Mul_520_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4557344,
      .offset_end = 4557472,
      .offset_limit = 4557536,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Mul_520_param1_quant_scale,
      .offset = buff_info_Mul_520_param1_quant_offset,
    },
    {
      .name = "Sub_526_param0",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4558880,
      .offset_end = 4559008,
      .offset_limit = 4559072,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Sub_526_param0_quant_scale,
      .offset = buff_info_Sub_526_param0_quant_offset,
    },
    {
      .name = "Mul_591_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4557472,
      .offset_end = 4557600,
      .offset_limit = 4557664,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Mul_591_param1_quant_scale,
      .offset = buff_info_Mul_591_param1_quant_offset,
    },
    {
      .name = "Sub_597_param0",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4559008,
      .offset_end = 4559136,
      .offset_limit = 4559200,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Sub_597_param0_quant_scale,
      .offset = buff_info_Sub_597_param0_quant_offset,
    },
    {
      .name = "Add_609_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4554400,
      .offset_end = 4555424,
      .offset_limit = 4555488,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_1024,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_1024,
      .per_channel = 0,
      .scale = buff_info_Add_609_param1_quant_scale,
      .offset = buff_info_Add_609_param1_quant_offset,
    },
    {
      .name = "Mul_635_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4557600,
      .offset_end = 4557728,
      .offset_limit = 4557792,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Mul_635_param1_quant_scale,
      .offset = buff_info_Mul_635_param1_quant_offset,
    },
    {
      .name = "Sub_641_param0",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4559136,
      .offset_end = 4559264,
      .offset_limit = 4559328,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Sub_641_param0_quant_scale,
      .offset = buff_info_Sub_641_param0_quant_offset,
    },
    {
      .name = "Mul_706_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4557728,
      .offset_end = 4557856,
      .offset_limit = 4557920,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Mul_706_param1_quant_scale,
      .offset = buff_info_Mul_706_param1_quant_offset,
    },
    {
      .name = "Sub_712_param0",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4559264,
      .offset_end = 4559392,
      .offset_limit = 4559456,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Sub_712_param0_quant_scale,
      .offset = buff_info_Sub_712_param0_quant_offset,
    },
    {
      .name = "Add_724_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4555424,
      .offset_end = 4556448,
      .offset_limit = 4556512,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_1024,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_1024,
      .per_channel = 0,
      .scale = buff_info_Add_724_param1_quant_scale,
      .offset = buff_info_Add_724_param1_quant_offset,
    },
    {
      .name = "Mul_750_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4557856,
      .offset_end = 4557984,
      .offset_limit = 4558048,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Mul_750_param1_quant_scale,
      .offset = buff_info_Mul_750_param1_quant_offset,
    },
    {
      .name = "Sub_756_param0",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4559392,
      .offset_end = 4559520,
      .offset_limit = 4559584,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_128,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_128,
      .per_channel = 0,
      .scale = buff_info_Sub_756_param0_quant_scale,
      .offset = buff_info_Sub_756_param0_quant_offset,
    },
    {
      .name = "Add_768_param1",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4133248,
      .offset_end = 4153248,
      .offset_limit = 4153312,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_1_20000,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_1_20000,
      .per_channel = 0,
      .scale = buff_info_Add_768_param1_quant_scale,
      .offset = buff_info_Add_768_param1_quant_offset,
    },
    {
      .name = "Gemm_77_weights_transposed_291",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4153248,
      .offset_end = 4169632,
      .offset_limit = 4169696,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_77_weights_transposed_291_quant_scale,
      .offset = buff_info_Gemm_77_weights_transposed_291_quant_offset,
    },
    {
      .name = "Gemm_85_weights_transposed_298",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4169632,
      .offset_end = 4186016,
      .offset_limit = 4186080,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_85_weights_transposed_298_quant_scale,
      .offset = buff_info_Gemm_85_weights_transposed_298_quant_offset,
    },
    {
      .name = "Gemm_93_weights_transposed_305",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4186016,
      .offset_end = 4202400,
      .offset_limit = 4202464,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_93_weights_transposed_305_quant_scale,
      .offset = buff_info_Gemm_93_weights_transposed_305_quant_offset,
    },
    {
      .name = "Gemm_111_weights_transposed_368",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4202400,
      .offset_end = 4218784,
      .offset_limit = 4218848,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_111_weights_transposed_368_quant_scale,
      .offset = buff_info_Gemm_111_weights_transposed_368_quant_offset,
    },
    {
      .name = "Gemm_146_weights_transposed_375",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 3346816,
      .offset_end = 3477888,
      .offset_limit = 3477952,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_1024_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1024_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_146_weights_transposed_375_quant_scale,
      .offset = buff_info_Gemm_146_weights_transposed_375_quant_offset,
    },
    {
      .name = "Gemm_155_weights_transposed_382",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 2560000,
      .offset_end = 2691136,
      .offset_limit = 2691200,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 128,
      .mem_shape = buff_info__mem_shape_M128_128_1024_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_1024_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_155_weights_transposed_382_quant_scale,
      .offset = buff_info_Gemm_155_weights_transposed_382_quant_offset,
    },
    {
      .name = "Gemm_192_weights_transposed_389",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4218784,
      .offset_end = 4235168,
      .offset_limit = 4235232,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_192_weights_transposed_389_quant_scale,
      .offset = buff_info_Gemm_192_weights_transposed_389_quant_offset,
    },
    {
      .name = "Gemm_200_weights_transposed_396",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4235168,
      .offset_end = 4251552,
      .offset_limit = 4251616,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_200_weights_transposed_396_quant_scale,
      .offset = buff_info_Gemm_200_weights_transposed_396_quant_offset,
    },
    {
      .name = "Gemm_208_weights_transposed_403",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4251552,
      .offset_end = 4267936,
      .offset_limit = 4268000,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_208_weights_transposed_403_quant_scale,
      .offset = buff_info_Gemm_208_weights_transposed_403_quant_offset,
    },
    {
      .name = "Gemm_226_weights_transposed_466",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4267936,
      .offset_end = 4284320,
      .offset_limit = 4284384,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_226_weights_transposed_466_quant_scale,
      .offset = buff_info_Gemm_226_weights_transposed_466_quant_offset,
    },
    {
      .name = "Gemm_261_weights_transposed_473",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 3477888,
      .offset_end = 3608960,
      .offset_limit = 3609024,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_1024_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1024_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_261_weights_transposed_473_quant_scale,
      .offset = buff_info_Gemm_261_weights_transposed_473_quant_offset,
    },
    {
      .name = "Gemm_270_weights_transposed_480",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 2691136,
      .offset_end = 2822272,
      .offset_limit = 2822336,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 128,
      .mem_shape = buff_info__mem_shape_M128_128_1024_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_1024_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_270_weights_transposed_480_quant_scale,
      .offset = buff_info_Gemm_270_weights_transposed_480_quant_offset,
    },
    {
      .name = "Gemm_307_weights_transposed_487",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4284320,
      .offset_end = 4300704,
      .offset_limit = 4300768,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_307_weights_transposed_487_quant_scale,
      .offset = buff_info_Gemm_307_weights_transposed_487_quant_offset,
    },
    {
      .name = "Gemm_315_weights_transposed_494",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4300704,
      .offset_end = 4317088,
      .offset_limit = 4317152,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_315_weights_transposed_494_quant_scale,
      .offset = buff_info_Gemm_315_weights_transposed_494_quant_offset,
    },
    {
      .name = "Gemm_323_weights_transposed_501",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4317088,
      .offset_end = 4333472,
      .offset_limit = 4333536,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_323_weights_transposed_501_quant_scale,
      .offset = buff_info_Gemm_323_weights_transposed_501_quant_offset,
    },
    {
      .name = "Gemm_341_weights_transposed_564",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4333472,
      .offset_end = 4349856,
      .offset_limit = 4349920,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_341_weights_transposed_564_quant_scale,
      .offset = buff_info_Gemm_341_weights_transposed_564_quant_offset,
    },
    {
      .name = "Gemm_376_weights_transposed_571",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 3608960,
      .offset_end = 3740032,
      .offset_limit = 3740096,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_1024_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1024_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_376_weights_transposed_571_quant_scale,
      .offset = buff_info_Gemm_376_weights_transposed_571_quant_offset,
    },
    {
      .name = "Gemm_385_weights_transposed_578",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 2822272,
      .offset_end = 2953408,
      .offset_limit = 2953472,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 128,
      .mem_shape = buff_info__mem_shape_M128_128_1024_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_1024_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_385_weights_transposed_578_quant_scale,
      .offset = buff_info_Gemm_385_weights_transposed_578_quant_offset,
    },
    {
      .name = "Gemm_422_weights_transposed_585",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4349856,
      .offset_end = 4366240,
      .offset_limit = 4366304,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_422_weights_transposed_585_quant_scale,
      .offset = buff_info_Gemm_422_weights_transposed_585_quant_offset,
    },
    {
      .name = "Gemm_430_weights_transposed_592",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4366240,
      .offset_end = 4382624,
      .offset_limit = 4382688,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_430_weights_transposed_592_quant_scale,
      .offset = buff_info_Gemm_430_weights_transposed_592_quant_offset,
    },
    {
      .name = "Gemm_438_weights_transposed_599",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4382624,
      .offset_end = 4399008,
      .offset_limit = 4399072,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_438_weights_transposed_599_quant_scale,
      .offset = buff_info_Gemm_438_weights_transposed_599_quant_offset,
    },
    {
      .name = "Gemm_456_weights_transposed_662",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4399008,
      .offset_end = 4415392,
      .offset_limit = 4415456,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_456_weights_transposed_662_quant_scale,
      .offset = buff_info_Gemm_456_weights_transposed_662_quant_offset,
    },
    {
      .name = "Gemm_491_weights_transposed_669",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 3740032,
      .offset_end = 3871104,
      .offset_limit = 3871168,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_1024_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1024_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_491_weights_transposed_669_quant_scale,
      .offset = buff_info_Gemm_491_weights_transposed_669_quant_offset,
    },
    {
      .name = "Gemm_500_weights_transposed_676",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 2953408,
      .offset_end = 3084544,
      .offset_limit = 3084608,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 128,
      .mem_shape = buff_info__mem_shape_M128_128_1024_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_1024_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_500_weights_transposed_676_quant_scale,
      .offset = buff_info_Gemm_500_weights_transposed_676_quant_offset,
    },
    {
      .name = "Gemm_537_weights_transposed_683",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4415392,
      .offset_end = 4431776,
      .offset_limit = 4431840,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_537_weights_transposed_683_quant_scale,
      .offset = buff_info_Gemm_537_weights_transposed_683_quant_offset,
    },
    {
      .name = "Gemm_545_weights_transposed_690",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4431776,
      .offset_end = 4448160,
      .offset_limit = 4448224,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_545_weights_transposed_690_quant_scale,
      .offset = buff_info_Gemm_545_weights_transposed_690_quant_offset,
    },
    {
      .name = "Gemm_553_weights_transposed_697",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4448160,
      .offset_end = 4464544,
      .offset_limit = 4464608,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_553_weights_transposed_697_quant_scale,
      .offset = buff_info_Gemm_553_weights_transposed_697_quant_offset,
    },
    {
      .name = "Gemm_571_weights_transposed_760",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4464544,
      .offset_end = 4480928,
      .offset_limit = 4480992,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_571_weights_transposed_760_quant_scale,
      .offset = buff_info_Gemm_571_weights_transposed_760_quant_offset,
    },
    {
      .name = "Gemm_606_weights_transposed_767",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 3871104,
      .offset_end = 4002176,
      .offset_limit = 4002240,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_1024_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1024_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_606_weights_transposed_767_quant_scale,
      .offset = buff_info_Gemm_606_weights_transposed_767_quant_offset,
    },
    {
      .name = "Gemm_615_weights_transposed_774",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 3084544,
      .offset_end = 3215680,
      .offset_limit = 3215744,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 128,
      .mem_shape = buff_info__mem_shape_M128_128_1024_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_1024_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_615_weights_transposed_774_quant_scale,
      .offset = buff_info_Gemm_615_weights_transposed_774_quant_offset,
    },
    {
      .name = "Gemm_652_weights_transposed_781",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4480928,
      .offset_end = 4497312,
      .offset_limit = 4497376,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_652_weights_transposed_781_quant_scale,
      .offset = buff_info_Gemm_652_weights_transposed_781_quant_offset,
    },
    {
      .name = "Gemm_660_weights_transposed_788",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4497312,
      .offset_end = 4513696,
      .offset_limit = 4513760,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_660_weights_transposed_788_quant_scale,
      .offset = buff_info_Gemm_660_weights_transposed_788_quant_offset,
    },
    {
      .name = "Gemm_668_weights_transposed_795",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4513696,
      .offset_end = 4530080,
      .offset_limit = 4530144,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_668_weights_transposed_795_quant_scale,
      .offset = buff_info_Gemm_668_weights_transposed_795_quant_offset,
    },
    {
      .name = "Gemm_686_weights_transposed_858",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4530080,
      .offset_end = 4546464,
      .offset_limit = 4546528,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_128_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_686_weights_transposed_858_quant_scale,
      .offset = buff_info_Gemm_686_weights_transposed_858_quant_offset,
    },
    {
      .name = "Gemm_721_weights_transposed_865",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4002176,
      .offset_end = 4133248,
      .offset_limit = 4133312,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_1024_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1024_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_721_weights_transposed_865_quant_scale,
      .offset = buff_info_Gemm_721_weights_transposed_865_quant_offset,
    },
    {
      .name = "Gemm_730_weights_transposed_872",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 3215680,
      .offset_end = 3346816,
      .offset_limit = 3346880,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 128,
      .mem_shape = buff_info__mem_shape_M128_128_1024_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_128_1024_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_730_weights_transposed_872_quant_scale,
      .offset = buff_info_Gemm_730_weights_transposed_872_quant_offset,
    },
    {
      .name = "Gemm_765_weights_transposed_879",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 0,
      .offset_end = 2560000,
      .offset_limit = 2560064,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 16,
      .mem_shape = buff_info__mem_shape_M16_20000_128_1_1,
      .mem_ndims = 5,
      .chpos = CHPos_Mixed,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_20000_128_1_1,
      .per_channel = 0,
      .scale = buff_info_Gemm_765_weights_transposed_879_quant_scale,
      .offset = buff_info_Gemm_765_weights_transposed_879_quant_offset,
    },
    {
      .name = "Gemm_102_gemm_11_1_conv_320_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4562592,
      .offset_end = 4562712,
      .offset_limit = 4562776,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_102_gemm_15_2_conv_327_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4563488,
      .offset_end = 4563608,
      .offset_limit = 4563672,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_102_gemm_7_0_conv_313_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4563360,
      .offset_end = 4563480,
      .offset_limit = 4563544,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_102_gemm_19_3_conv_334_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4563616,
      .offset_end = 4563736,
      .offset_limit = 4563800,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_107_gemm_35_1_conv_348_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4559520,
      .offset_end = 4559640,
      .offset_limit = 4559704,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_107_gemm_39_2_conv_355_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4560416,
      .offset_end = 4560536,
      .offset_limit = 4560600,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_107_gemm_43_3_conv_362_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4560544,
      .offset_end = 4560664,
      .offset_limit = 4560728,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_107_gemm_31_0_conv_341_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4560288,
      .offset_end = 4560408,
      .offset_limit = 4560472,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_217_gemm_59_1_conv_418_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4562720,
      .offset_end = 4562840,
      .offset_limit = 4562904,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_217_gemm_63_2_conv_425_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4563872,
      .offset_end = 4563992,
      .offset_limit = 4564056,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_217_gemm_67_3_conv_432_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4564000,
      .offset_end = 4564120,
      .offset_limit = 4564184,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_217_gemm_55_0_conv_411_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4563744,
      .offset_end = 4563864,
      .offset_limit = 4563928,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_222_gemm_87_2_conv_453_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4559648,
      .offset_end = 4559768,
      .offset_limit = 4559832,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_222_gemm_91_3_conv_460_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4560928,
      .offset_end = 4561048,
      .offset_limit = 4561112,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_222_gemm_79_0_conv_439_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4560672,
      .offset_end = 4560792,
      .offset_limit = 4560856,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_222_gemm_83_1_conv_446_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4560800,
      .offset_end = 4560920,
      .offset_limit = 4560984,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_332_gemm_103_0_conv_509_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4562848,
      .offset_end = 4562968,
      .offset_limit = 4563032,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_332_gemm_107_1_conv_516_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4564128,
      .offset_end = 4564248,
      .offset_limit = 4564312,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_332_gemm_111_2_conv_523_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4564256,
      .offset_end = 4564376,
      .offset_limit = 4564440,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_332_gemm_115_3_conv_530_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4564384,
      .offset_end = 4564504,
      .offset_limit = 4564568,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_337_gemm_139_3_conv_558_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4559776,
      .offset_end = 4559896,
      .offset_limit = 4559960,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_337_gemm_127_0_conv_537_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4561056,
      .offset_end = 4561176,
      .offset_limit = 4561240,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_337_gemm_131_1_conv_544_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4561184,
      .offset_end = 4561304,
      .offset_limit = 4561368,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_337_gemm_135_2_conv_551_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4561312,
      .offset_end = 4561432,
      .offset_limit = 4561496,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_447_gemm_155_1_conv_614_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4562976,
      .offset_end = 4563096,
      .offset_limit = 4563160,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_447_gemm_159_2_conv_621_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4564640,
      .offset_end = 4564760,
      .offset_limit = 4564824,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_447_gemm_163_3_conv_628_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4564768,
      .offset_end = 4564888,
      .offset_limit = 4564952,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_447_gemm_151_0_conv_607_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4564512,
      .offset_end = 4564632,
      .offset_limit = 4564696,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_452_gemm_187_3_conv_656_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4559904,
      .offset_end = 4560024,
      .offset_limit = 4560088,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_452_gemm_175_0_conv_635_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4561440,
      .offset_end = 4561560,
      .offset_limit = 4561624,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_452_gemm_179_1_conv_642_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4561568,
      .offset_end = 4561688,
      .offset_limit = 4561752,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_452_gemm_183_2_conv_649_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4561696,
      .offset_end = 4561816,
      .offset_limit = 4561880,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_562_gemm_207_2_conv_719_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4563104,
      .offset_end = 4563224,
      .offset_limit = 4563288,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_562_gemm_199_0_conv_705_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4564896,
      .offset_end = 4565016,
      .offset_limit = 4565080,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_562_gemm_211_3_conv_726_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565152,
      .offset_end = 4565272,
      .offset_limit = 4565336,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_562_gemm_203_1_conv_712_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565024,
      .offset_end = 4565144,
      .offset_limit = 4565208,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_567_gemm_235_3_conv_754_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4560032,
      .offset_end = 4560152,
      .offset_limit = 4560216,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_567_gemm_223_0_conv_733_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4561824,
      .offset_end = 4561944,
      .offset_limit = 4562008,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_567_gemm_227_1_conv_740_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4561952,
      .offset_end = 4562072,
      .offset_limit = 4562136,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_567_gemm_231_2_conv_747_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4562080,
      .offset_end = 4562200,
      .offset_limit = 4562264,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_677_gemm_259_3_conv_824_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4563232,
      .offset_end = 4563352,
      .offset_limit = 4563416,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_677_gemm_247_0_conv_803_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565280,
      .offset_end = 4565400,
      .offset_limit = 4565464,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_677_gemm_251_1_conv_810_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565408,
      .offset_end = 4565528,
      .offset_limit = 4565592,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_677_gemm_255_2_conv_817_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565536,
      .offset_end = 4565656,
      .offset_limit = 4565720,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_682_gemm_279_2_conv_845_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4560160,
      .offset_end = 4560280,
      .offset_limit = 4560344,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_682_gemm_283_3_conv_852_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4562464,
      .offset_end = 4562584,
      .offset_limit = 4562648,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_682_gemm_271_0_conv_831_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4562208,
      .offset_end = 4562328,
      .offset_limit = 4562392,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Gemm_682_gemm_275_1_conv_838_Dummy_BIAS",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4562336,
      .offset_end = 4562456,
      .offset_limit = 4562520,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_30,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_30,
    },
    {
      .name = "Identity_inserted_id2365_3184_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568160,
      .offset_end = 4568164,
      .offset_limit = 4568232,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2365_3184_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572384,
      .offset_end = 4572385,
      .offset_limit = 4572456,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_102_gemm_11_1_reshape_w_319_3186_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568176,
      .offset_end = 4568180,
      .offset_limit = 4568248,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_102_gemm_11_1_reshape_w_319_3186_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572400,
      .offset_end = 4572401,
      .offset_limit = 4572472,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_102_gemm_11_1_conv_320_3188_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568192,
      .offset_end = 4568196,
      .offset_limit = 4568264,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_102_gemm_11_1_conv_320_3188_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572416,
      .offset_end = 4572417,
      .offset_limit = 4572488,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2366_3190_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568496,
      .offset_end = 4568500,
      .offset_limit = 4568568,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2366_3190_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572720,
      .offset_end = 4572721,
      .offset_limit = 4572792,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_102_gemm_15_2_reshape_w_326_3192_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568512,
      .offset_end = 4568516,
      .offset_limit = 4568584,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_102_gemm_15_2_reshape_w_326_3192_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572736,
      .offset_end = 4572737,
      .offset_limit = 4572808,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_102_gemm_15_2_conv_327_3194_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568528,
      .offset_end = 4568532,
      .offset_limit = 4568600,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_102_gemm_15_2_conv_327_3194_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572752,
      .offset_end = 4572753,
      .offset_limit = 4572824,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2367_3196_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568448,
      .offset_end = 4568452,
      .offset_limit = 4568520,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2367_3196_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572672,
      .offset_end = 4572673,
      .offset_limit = 4572744,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_102_gemm_7_0_reshape_w_312_3198_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568464,
      .offset_end = 4568468,
      .offset_limit = 4568536,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_102_gemm_7_0_reshape_w_312_3198_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572688,
      .offset_end = 4572689,
      .offset_limit = 4572760,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_102_gemm_7_0_conv_313_3200_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568480,
      .offset_end = 4568484,
      .offset_limit = 4568552,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_102_gemm_7_0_conv_313_3200_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572704,
      .offset_end = 4572705,
      .offset_limit = 4572776,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2368_3202_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568544,
      .offset_end = 4568548,
      .offset_limit = 4568616,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2368_3202_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572768,
      .offset_end = 4572769,
      .offset_limit = 4572840,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_102_gemm_19_3_reshape_w_333_3204_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568560,
      .offset_end = 4568564,
      .offset_limit = 4568632,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_102_gemm_19_3_reshape_w_333_3204_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572784,
      .offset_end = 4572785,
      .offset_limit = 4572856,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_102_gemm_19_3_conv_334_3206_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568576,
      .offset_end = 4568580,
      .offset_limit = 4568648,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_102_gemm_19_3_conv_334_3206_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572800,
      .offset_end = 4572801,
      .offset_limit = 4572872,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_103_mul_sub2__3208_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566400,
      .offset_end = 4566404,
      .offset_limit = 4566472,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_103_mul_sub2__3208_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570624,
      .offset_end = 4570625,
      .offset_limit = 4570696,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Softmax_106_3210_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566416,
      .offset_end = 4566420,
      .offset_limit = 4566488,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Softmax_106_3210_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570640,
      .offset_end = 4570641,
      .offset_limit = 4570712,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2380_3212_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567008,
      .offset_end = 4567012,
      .offset_limit = 4567080,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2380_3212_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571232,
      .offset_end = 4571233,
      .offset_limit = 4571304,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_107_gemm_35_1_reshape_w_347_3214_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567024,
      .offset_end = 4567028,
      .offset_limit = 4567096,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_107_gemm_35_1_reshape_w_347_3214_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571248,
      .offset_end = 4571249,
      .offset_limit = 4571320,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_107_gemm_35_1_conv_348_3216_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567040,
      .offset_end = 4567044,
      .offset_limit = 4567112,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_107_gemm_35_1_conv_348_3216_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571264,
      .offset_end = 4571265,
      .offset_limit = 4571336,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2382_3218_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567344,
      .offset_end = 4567348,
      .offset_limit = 4567416,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2382_3218_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571568,
      .offset_end = 4571569,
      .offset_limit = 4571640,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_107_gemm_39_2_reshape_w_354_3220_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567360,
      .offset_end = 4567364,
      .offset_limit = 4567432,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_107_gemm_39_2_reshape_w_354_3220_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571584,
      .offset_end = 4571585,
      .offset_limit = 4571656,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_107_gemm_39_2_conv_355_3222_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567376,
      .offset_end = 4567380,
      .offset_limit = 4567448,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_107_gemm_39_2_conv_355_3222_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571600,
      .offset_end = 4571601,
      .offset_limit = 4571672,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2384_3224_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567392,
      .offset_end = 4567396,
      .offset_limit = 4567464,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2384_3224_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571616,
      .offset_end = 4571617,
      .offset_limit = 4571688,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_107_gemm_43_3_reshape_w_361_3226_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567408,
      .offset_end = 4567412,
      .offset_limit = 4567480,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_107_gemm_43_3_reshape_w_361_3226_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571632,
      .offset_end = 4571633,
      .offset_limit = 4571704,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_107_gemm_43_3_conv_362_3228_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567424,
      .offset_end = 4567428,
      .offset_limit = 4567496,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_107_gemm_43_3_conv_362_3228_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571648,
      .offset_end = 4571649,
      .offset_limit = 4571720,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2386_3230_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567296,
      .offset_end = 4567300,
      .offset_limit = 4567368,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2386_3230_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571520,
      .offset_end = 4571521,
      .offset_limit = 4571592,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_107_gemm_31_0_reshape_w_340_3232_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567312,
      .offset_end = 4567316,
      .offset_limit = 4567384,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_107_gemm_31_0_reshape_w_340_3232_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571536,
      .offset_end = 4571537,
      .offset_limit = 4571608,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_107_gemm_31_0_conv_341_3234_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567328,
      .offset_end = 4567332,
      .offset_limit = 4567400,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_107_gemm_31_0_conv_341_3234_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571552,
      .offset_end = 4571553,
      .offset_limit = 4571624,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_129_3238_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569312,
      .offset_end = 4569316,
      .offset_limit = 4569384,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_129_3238_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573536,
      .offset_end = 4573537,
      .offset_limit = 4573608,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2417_3240_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569520,
      .offset_end = 4569524,
      .offset_limit = 4569592,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2417_3240_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573744,
      .offset_end = 4573745,
      .offset_limit = 4573816,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2416_3242_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569504,
      .offset_end = 4569508,
      .offset_limit = 4569576,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2416_3242_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573728,
      .offset_end = 4573729,
      .offset_limit = 4573800,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2416_3244_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565664,
      .offset_end = 4565668,
      .offset_limit = 4565736,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2416_3244_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569888,
      .offset_end = 4569889,
      .offset_limit = 4569960,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_131_param1_3246_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565680,
      .offset_end = 4565684,
      .offset_limit = 4565752,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_131_param1_3246_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569904,
      .offset_end = 4569905,
      .offset_limit = 4569976,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_131_3248_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565696,
      .offset_end = 4565700,
      .offset_limit = 4565768,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_131_3248_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569920,
      .offset_end = 4569921,
      .offset_limit = 4569992,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_137_param0_3251_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566432,
      .offset_end = 4566436,
      .offset_limit = 4566504,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_137_param0_3251_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570656,
      .offset_end = 4570657,
      .offset_limit = 4570728,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_134_mul_sub2__3253_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566448,
      .offset_end = 4566452,
      .offset_limit = 4566520,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_134_mul_sub2__3253_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570672,
      .offset_end = 4570673,
      .offset_limit = 4570744,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_137_3255_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566464,
      .offset_end = 4566468,
      .offset_limit = 4566536,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_137_3255_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570688,
      .offset_end = 4570689,
      .offset_limit = 4570760,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_173_3259_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569328,
      .offset_end = 4569332,
      .offset_limit = 4569400,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_173_3259_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573552,
      .offset_end = 4573553,
      .offset_limit = 4573624,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2467_3261_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569552,
      .offset_end = 4569556,
      .offset_limit = 4569624,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2467_3261_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573776,
      .offset_end = 4573777,
      .offset_limit = 4573848,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2466_3263_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569536,
      .offset_end = 4569540,
      .offset_limit = 4569608,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2466_3263_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573760,
      .offset_end = 4573761,
      .offset_limit = 4573832,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2466_3265_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565712,
      .offset_end = 4565716,
      .offset_limit = 4565784,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2466_3265_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569936,
      .offset_end = 4569937,
      .offset_limit = 4570008,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_175_param1_3267_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565728,
      .offset_end = 4565732,
      .offset_limit = 4565800,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_175_param1_3267_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569952,
      .offset_end = 4569953,
      .offset_limit = 4570024,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_175_3269_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565744,
      .offset_end = 4565748,
      .offset_limit = 4565816,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_175_3269_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569968,
      .offset_end = 4569969,
      .offset_limit = 4570040,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_181_param0_3272_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566480,
      .offset_end = 4566484,
      .offset_limit = 4566552,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_181_param0_3272_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570704,
      .offset_end = 4570705,
      .offset_limit = 4570776,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_178_mul_sub2__3274_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566496,
      .offset_end = 4566500,
      .offset_limit = 4566568,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_178_mul_sub2__3274_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570720,
      .offset_end = 4570721,
      .offset_limit = 4570792,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_181_3276_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566512,
      .offset_end = 4566516,
      .offset_limit = 4566584,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_181_3276_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570736,
      .offset_end = 4570737,
      .offset_limit = 4570808,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2504_3278_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568208,
      .offset_end = 4568212,
      .offset_limit = 4568280,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2504_3278_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572432,
      .offset_end = 4572433,
      .offset_limit = 4572504,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_217_gemm_59_1_reshape_w_417_3280_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568224,
      .offset_end = 4568228,
      .offset_limit = 4568296,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_217_gemm_59_1_reshape_w_417_3280_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572448,
      .offset_end = 4572449,
      .offset_limit = 4572520,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_217_gemm_59_1_conv_418_3282_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568240,
      .offset_end = 4568244,
      .offset_limit = 4568312,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_217_gemm_59_1_conv_418_3282_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572464,
      .offset_end = 4572465,
      .offset_limit = 4572536,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2505_3284_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568640,
      .offset_end = 4568644,
      .offset_limit = 4568712,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2505_3284_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572864,
      .offset_end = 4572865,
      .offset_limit = 4572936,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_217_gemm_63_2_reshape_w_424_3286_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568656,
      .offset_end = 4568660,
      .offset_limit = 4568728,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_217_gemm_63_2_reshape_w_424_3286_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572880,
      .offset_end = 4572881,
      .offset_limit = 4572952,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_217_gemm_63_2_conv_425_3288_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568672,
      .offset_end = 4568676,
      .offset_limit = 4568744,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_217_gemm_63_2_conv_425_3288_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572896,
      .offset_end = 4572897,
      .offset_limit = 4572968,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2506_3290_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568688,
      .offset_end = 4568692,
      .offset_limit = 4568760,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2506_3290_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572912,
      .offset_end = 4572913,
      .offset_limit = 4572984,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_217_gemm_67_3_reshape_w_431_3292_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568704,
      .offset_end = 4568708,
      .offset_limit = 4568776,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_217_gemm_67_3_reshape_w_431_3292_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572928,
      .offset_end = 4572929,
      .offset_limit = 4573000,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_217_gemm_67_3_conv_432_3294_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568720,
      .offset_end = 4568724,
      .offset_limit = 4568792,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_217_gemm_67_3_conv_432_3294_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572944,
      .offset_end = 4572945,
      .offset_limit = 4573016,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2507_3296_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568592,
      .offset_end = 4568596,
      .offset_limit = 4568664,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2507_3296_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572816,
      .offset_end = 4572817,
      .offset_limit = 4572888,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_217_gemm_55_0_reshape_w_410_3298_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568608,
      .offset_end = 4568612,
      .offset_limit = 4568680,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_217_gemm_55_0_reshape_w_410_3298_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572832,
      .offset_end = 4572833,
      .offset_limit = 4572904,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_217_gemm_55_0_conv_411_3300_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568624,
      .offset_end = 4568628,
      .offset_limit = 4568696,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_217_gemm_55_0_conv_411_3300_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572848,
      .offset_end = 4572849,
      .offset_limit = 4572920,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_218_mul_sub2__3302_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566240,
      .offset_end = 4566244,
      .offset_limit = 4566312,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_218_mul_sub2__3302_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570464,
      .offset_end = 4570465,
      .offset_limit = 4570536,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Softmax_221_3304_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566256,
      .offset_end = 4566260,
      .offset_limit = 4566328,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Softmax_221_3304_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570480,
      .offset_end = 4570481,
      .offset_limit = 4570552,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2519_3306_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567056,
      .offset_end = 4567060,
      .offset_limit = 4567128,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2519_3306_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571280,
      .offset_end = 4571281,
      .offset_limit = 4571352,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_222_gemm_87_2_reshape_w_452_3308_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567072,
      .offset_end = 4567076,
      .offset_limit = 4567144,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_222_gemm_87_2_reshape_w_452_3308_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571296,
      .offset_end = 4571297,
      .offset_limit = 4571368,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_222_gemm_87_2_conv_453_3310_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567088,
      .offset_end = 4567092,
      .offset_limit = 4567160,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_222_gemm_87_2_conv_453_3310_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571312,
      .offset_end = 4571313,
      .offset_limit = 4571384,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2521_3312_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567536,
      .offset_end = 4567540,
      .offset_limit = 4567608,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2521_3312_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571760,
      .offset_end = 4571761,
      .offset_limit = 4571832,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_222_gemm_91_3_reshape_w_459_3314_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567552,
      .offset_end = 4567556,
      .offset_limit = 4567624,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_222_gemm_91_3_reshape_w_459_3314_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571776,
      .offset_end = 4571777,
      .offset_limit = 4571848,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_222_gemm_91_3_conv_460_3316_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567568,
      .offset_end = 4567572,
      .offset_limit = 4567640,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_222_gemm_91_3_conv_460_3316_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571792,
      .offset_end = 4571793,
      .offset_limit = 4571864,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2523_3318_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567440,
      .offset_end = 4567444,
      .offset_limit = 4567512,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2523_3318_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571664,
      .offset_end = 4571665,
      .offset_limit = 4571736,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_222_gemm_79_0_reshape_w_438_3320_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567456,
      .offset_end = 4567460,
      .offset_limit = 4567528,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_222_gemm_79_0_reshape_w_438_3320_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571680,
      .offset_end = 4571681,
      .offset_limit = 4571752,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_222_gemm_79_0_conv_439_3322_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567472,
      .offset_end = 4567476,
      .offset_limit = 4567544,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_222_gemm_79_0_conv_439_3322_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571696,
      .offset_end = 4571697,
      .offset_limit = 4571768,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2525_3324_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567488,
      .offset_end = 4567492,
      .offset_limit = 4567560,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2525_3324_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571712,
      .offset_end = 4571713,
      .offset_limit = 4571784,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_222_gemm_83_1_reshape_w_445_3326_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567504,
      .offset_end = 4567508,
      .offset_limit = 4567576,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_222_gemm_83_1_reshape_w_445_3326_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571728,
      .offset_end = 4571729,
      .offset_limit = 4571800,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_222_gemm_83_1_conv_446_3328_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567520,
      .offset_end = 4567524,
      .offset_limit = 4567592,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_222_gemm_83_1_conv_446_3328_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571744,
      .offset_end = 4571745,
      .offset_limit = 4571816,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_244_3332_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569344,
      .offset_end = 4569348,
      .offset_limit = 4569416,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_244_3332_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573568,
      .offset_end = 4573569,
      .offset_limit = 4573640,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2556_3334_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569584,
      .offset_end = 4569588,
      .offset_limit = 4569656,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2556_3334_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573808,
      .offset_end = 4573809,
      .offset_limit = 4573880,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2555_3336_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569568,
      .offset_end = 4569572,
      .offset_limit = 4569640,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2555_3336_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573792,
      .offset_end = 4573793,
      .offset_limit = 4573864,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2555_3338_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565760,
      .offset_end = 4565764,
      .offset_limit = 4565832,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2555_3338_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569984,
      .offset_end = 4569985,
      .offset_limit = 4570056,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_246_param1_3340_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565776,
      .offset_end = 4565780,
      .offset_limit = 4565848,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_246_param1_3340_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570000,
      .offset_end = 4570001,
      .offset_limit = 4570072,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_246_3342_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565792,
      .offset_end = 4565796,
      .offset_limit = 4565864,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_246_3342_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570016,
      .offset_end = 4570017,
      .offset_limit = 4570088,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_252_param0_3345_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566528,
      .offset_end = 4566532,
      .offset_limit = 4566600,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_252_param0_3345_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570752,
      .offset_end = 4570753,
      .offset_limit = 4570824,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_249_mul_sub2__3347_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566544,
      .offset_end = 4566548,
      .offset_limit = 4566616,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_249_mul_sub2__3347_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570768,
      .offset_end = 4570769,
      .offset_limit = 4570840,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_252_3349_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566560,
      .offset_end = 4566564,
      .offset_limit = 4566632,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_252_3349_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570784,
      .offset_end = 4570785,
      .offset_limit = 4570856,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_288_3353_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569360,
      .offset_end = 4569364,
      .offset_limit = 4569432,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_288_3353_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573584,
      .offset_end = 4573585,
      .offset_limit = 4573656,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2606_3355_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569616,
      .offset_end = 4569620,
      .offset_limit = 4569688,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2606_3355_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573840,
      .offset_end = 4573841,
      .offset_limit = 4573912,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2605_3357_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569600,
      .offset_end = 4569604,
      .offset_limit = 4569672,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2605_3357_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573824,
      .offset_end = 4573825,
      .offset_limit = 4573896,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2605_3359_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565808,
      .offset_end = 4565812,
      .offset_limit = 4565880,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2605_3359_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570032,
      .offset_end = 4570033,
      .offset_limit = 4570104,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_290_param1_3361_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565824,
      .offset_end = 4565828,
      .offset_limit = 4565896,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_290_param1_3361_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570048,
      .offset_end = 4570049,
      .offset_limit = 4570120,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_290_3363_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565840,
      .offset_end = 4565844,
      .offset_limit = 4565912,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_290_3363_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570064,
      .offset_end = 4570065,
      .offset_limit = 4570136,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_296_param0_3366_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566576,
      .offset_end = 4566580,
      .offset_limit = 4566648,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_296_param0_3366_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570800,
      .offset_end = 4570801,
      .offset_limit = 4570872,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_293_mul_sub2__3368_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566592,
      .offset_end = 4566596,
      .offset_limit = 4566664,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_293_mul_sub2__3368_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570816,
      .offset_end = 4570817,
      .offset_limit = 4570888,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_296_3370_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566608,
      .offset_end = 4566612,
      .offset_limit = 4566680,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_296_3370_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570832,
      .offset_end = 4570833,
      .offset_limit = 4570904,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2643_3372_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568256,
      .offset_end = 4568260,
      .offset_limit = 4568328,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2643_3372_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572480,
      .offset_end = 4572481,
      .offset_limit = 4572552,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_332_gemm_103_0_reshape_w_508_3374_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568272,
      .offset_end = 4568276,
      .offset_limit = 4568344,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_332_gemm_103_0_reshape_w_508_3374_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572496,
      .offset_end = 4572497,
      .offset_limit = 4572568,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_332_gemm_103_0_conv_509_3376_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568288,
      .offset_end = 4568292,
      .offset_limit = 4568360,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_332_gemm_103_0_conv_509_3376_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572512,
      .offset_end = 4572513,
      .offset_limit = 4572584,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2644_3378_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568736,
      .offset_end = 4568740,
      .offset_limit = 4568808,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2644_3378_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572960,
      .offset_end = 4572961,
      .offset_limit = 4573032,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_332_gemm_107_1_reshape_w_515_3380_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568752,
      .offset_end = 4568756,
      .offset_limit = 4568824,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_332_gemm_107_1_reshape_w_515_3380_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572976,
      .offset_end = 4572977,
      .offset_limit = 4573048,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_332_gemm_107_1_conv_516_3382_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568768,
      .offset_end = 4568772,
      .offset_limit = 4568840,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_332_gemm_107_1_conv_516_3382_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572992,
      .offset_end = 4572993,
      .offset_limit = 4573064,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2645_3384_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568784,
      .offset_end = 4568788,
      .offset_limit = 4568856,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2645_3384_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573008,
      .offset_end = 4573009,
      .offset_limit = 4573080,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_332_gemm_111_2_reshape_w_522_3386_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568800,
      .offset_end = 4568804,
      .offset_limit = 4568872,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_332_gemm_111_2_reshape_w_522_3386_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573024,
      .offset_end = 4573025,
      .offset_limit = 4573096,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_332_gemm_111_2_conv_523_3388_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568816,
      .offset_end = 4568820,
      .offset_limit = 4568888,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_332_gemm_111_2_conv_523_3388_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573040,
      .offset_end = 4573041,
      .offset_limit = 4573112,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2646_3390_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568832,
      .offset_end = 4568836,
      .offset_limit = 4568904,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2646_3390_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573056,
      .offset_end = 4573057,
      .offset_limit = 4573128,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_332_gemm_115_3_reshape_w_529_3392_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568848,
      .offset_end = 4568852,
      .offset_limit = 4568920,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_332_gemm_115_3_reshape_w_529_3392_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573072,
      .offset_end = 4573073,
      .offset_limit = 4573144,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_332_gemm_115_3_conv_530_3394_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568864,
      .offset_end = 4568868,
      .offset_limit = 4568936,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_332_gemm_115_3_conv_530_3394_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573088,
      .offset_end = 4573089,
      .offset_limit = 4573160,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_333_mul_sub2__3396_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566272,
      .offset_end = 4566276,
      .offset_limit = 4566344,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_333_mul_sub2__3396_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570496,
      .offset_end = 4570497,
      .offset_limit = 4570568,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Softmax_336_3398_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566288,
      .offset_end = 4566292,
      .offset_limit = 4566360,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Softmax_336_3398_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570512,
      .offset_end = 4570513,
      .offset_limit = 4570584,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2658_3400_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567104,
      .offset_end = 4567108,
      .offset_limit = 4567176,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2658_3400_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571328,
      .offset_end = 4571329,
      .offset_limit = 4571400,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_337_gemm_139_3_reshape_w_557_3402_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567120,
      .offset_end = 4567124,
      .offset_limit = 4567192,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_337_gemm_139_3_reshape_w_557_3402_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571344,
      .offset_end = 4571345,
      .offset_limit = 4571416,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_337_gemm_139_3_conv_558_3404_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567136,
      .offset_end = 4567140,
      .offset_limit = 4567208,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_337_gemm_139_3_conv_558_3404_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571360,
      .offset_end = 4571361,
      .offset_limit = 4571432,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2660_3406_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567584,
      .offset_end = 4567588,
      .offset_limit = 4567656,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2660_3406_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571808,
      .offset_end = 4571809,
      .offset_limit = 4571880,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_337_gemm_127_0_reshape_w_536_3408_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567600,
      .offset_end = 4567604,
      .offset_limit = 4567672,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_337_gemm_127_0_reshape_w_536_3408_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571824,
      .offset_end = 4571825,
      .offset_limit = 4571896,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_337_gemm_127_0_conv_537_3410_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567616,
      .offset_end = 4567620,
      .offset_limit = 4567688,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_337_gemm_127_0_conv_537_3410_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571840,
      .offset_end = 4571841,
      .offset_limit = 4571912,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2662_3412_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567632,
      .offset_end = 4567636,
      .offset_limit = 4567704,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2662_3412_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571856,
      .offset_end = 4571857,
      .offset_limit = 4571928,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_337_gemm_131_1_reshape_w_543_3414_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567648,
      .offset_end = 4567652,
      .offset_limit = 4567720,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_337_gemm_131_1_reshape_w_543_3414_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571872,
      .offset_end = 4571873,
      .offset_limit = 4571944,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_337_gemm_131_1_conv_544_3416_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567664,
      .offset_end = 4567668,
      .offset_limit = 4567736,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_337_gemm_131_1_conv_544_3416_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571888,
      .offset_end = 4571889,
      .offset_limit = 4571960,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2664_3418_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567680,
      .offset_end = 4567684,
      .offset_limit = 4567752,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2664_3418_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571904,
      .offset_end = 4571905,
      .offset_limit = 4571976,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_337_gemm_135_2_reshape_w_550_3420_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567696,
      .offset_end = 4567700,
      .offset_limit = 4567768,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_337_gemm_135_2_reshape_w_550_3420_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571920,
      .offset_end = 4571921,
      .offset_limit = 4571992,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_337_gemm_135_2_conv_551_3422_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567712,
      .offset_end = 4567716,
      .offset_limit = 4567784,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_337_gemm_135_2_conv_551_3422_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571936,
      .offset_end = 4571937,
      .offset_limit = 4572008,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_359_3426_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569376,
      .offset_end = 4569380,
      .offset_limit = 4569448,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_359_3426_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573600,
      .offset_end = 4573601,
      .offset_limit = 4573672,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2695_3428_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569648,
      .offset_end = 4569652,
      .offset_limit = 4569720,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2695_3428_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573872,
      .offset_end = 4573873,
      .offset_limit = 4573944,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2694_3430_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569632,
      .offset_end = 4569636,
      .offset_limit = 4569704,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2694_3430_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573856,
      .offset_end = 4573857,
      .offset_limit = 4573928,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2694_3432_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565856,
      .offset_end = 4565860,
      .offset_limit = 4565928,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2694_3432_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570080,
      .offset_end = 4570081,
      .offset_limit = 4570152,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_361_param1_3434_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565872,
      .offset_end = 4565876,
      .offset_limit = 4565944,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_361_param1_3434_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570096,
      .offset_end = 4570097,
      .offset_limit = 4570168,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_361_3436_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565888,
      .offset_end = 4565892,
      .offset_limit = 4565960,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_361_3436_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570112,
      .offset_end = 4570113,
      .offset_limit = 4570184,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_367_param0_3439_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566624,
      .offset_end = 4566628,
      .offset_limit = 4566696,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_367_param0_3439_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570848,
      .offset_end = 4570849,
      .offset_limit = 4570920,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_364_mul_sub2__3441_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566640,
      .offset_end = 4566644,
      .offset_limit = 4566712,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_364_mul_sub2__3441_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570864,
      .offset_end = 4570865,
      .offset_limit = 4570936,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_367_3443_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566656,
      .offset_end = 4566660,
      .offset_limit = 4566728,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_367_3443_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570880,
      .offset_end = 4570881,
      .offset_limit = 4570952,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_403_3447_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569392,
      .offset_end = 4569396,
      .offset_limit = 4569464,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_403_3447_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573616,
      .offset_end = 4573617,
      .offset_limit = 4573688,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2745_3449_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569680,
      .offset_end = 4569684,
      .offset_limit = 4569752,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2745_3449_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573904,
      .offset_end = 4573905,
      .offset_limit = 4573976,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2744_3451_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569664,
      .offset_end = 4569668,
      .offset_limit = 4569736,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2744_3451_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573888,
      .offset_end = 4573889,
      .offset_limit = 4573960,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2744_3453_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565904,
      .offset_end = 4565908,
      .offset_limit = 4565976,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2744_3453_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570128,
      .offset_end = 4570129,
      .offset_limit = 4570200,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_405_param1_3455_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565920,
      .offset_end = 4565924,
      .offset_limit = 4565992,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_405_param1_3455_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570144,
      .offset_end = 4570145,
      .offset_limit = 4570216,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_405_3457_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565936,
      .offset_end = 4565940,
      .offset_limit = 4566008,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_405_3457_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570160,
      .offset_end = 4570161,
      .offset_limit = 4570232,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_411_param0_3460_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566672,
      .offset_end = 4566676,
      .offset_limit = 4566744,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_411_param0_3460_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570896,
      .offset_end = 4570897,
      .offset_limit = 4570968,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_408_mul_sub2__3462_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566688,
      .offset_end = 4566692,
      .offset_limit = 4566760,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_408_mul_sub2__3462_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570912,
      .offset_end = 4570913,
      .offset_limit = 4570984,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_411_3464_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566704,
      .offset_end = 4566708,
      .offset_limit = 4566776,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_411_3464_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570928,
      .offset_end = 4570929,
      .offset_limit = 4571000,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2782_3466_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568304,
      .offset_end = 4568308,
      .offset_limit = 4568376,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2782_3466_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572528,
      .offset_end = 4572529,
      .offset_limit = 4572600,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_447_gemm_155_1_reshape_w_613_3468_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568320,
      .offset_end = 4568324,
      .offset_limit = 4568392,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_447_gemm_155_1_reshape_w_613_3468_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572544,
      .offset_end = 4572545,
      .offset_limit = 4572616,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_447_gemm_155_1_conv_614_3470_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568336,
      .offset_end = 4568340,
      .offset_limit = 4568408,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_447_gemm_155_1_conv_614_3470_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572560,
      .offset_end = 4572561,
      .offset_limit = 4572632,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2783_3472_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568928,
      .offset_end = 4568932,
      .offset_limit = 4569000,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2783_3472_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573152,
      .offset_end = 4573153,
      .offset_limit = 4573224,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_447_gemm_159_2_reshape_w_620_3474_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568944,
      .offset_end = 4568948,
      .offset_limit = 4569016,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_447_gemm_159_2_reshape_w_620_3474_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573168,
      .offset_end = 4573169,
      .offset_limit = 4573240,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_447_gemm_159_2_conv_621_3476_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568960,
      .offset_end = 4568964,
      .offset_limit = 4569032,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_447_gemm_159_2_conv_621_3476_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573184,
      .offset_end = 4573185,
      .offset_limit = 4573256,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2784_3478_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568976,
      .offset_end = 4568980,
      .offset_limit = 4569048,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2784_3478_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573200,
      .offset_end = 4573201,
      .offset_limit = 4573272,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_447_gemm_163_3_reshape_w_627_3480_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568992,
      .offset_end = 4568996,
      .offset_limit = 4569064,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_447_gemm_163_3_reshape_w_627_3480_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573216,
      .offset_end = 4573217,
      .offset_limit = 4573288,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_447_gemm_163_3_conv_628_3482_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569008,
      .offset_end = 4569012,
      .offset_limit = 4569080,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_447_gemm_163_3_conv_628_3482_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573232,
      .offset_end = 4573233,
      .offset_limit = 4573304,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2785_3484_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568880,
      .offset_end = 4568884,
      .offset_limit = 4568952,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2785_3484_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573104,
      .offset_end = 4573105,
      .offset_limit = 4573176,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_447_gemm_151_0_reshape_w_606_3486_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568896,
      .offset_end = 4568900,
      .offset_limit = 4568968,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_447_gemm_151_0_reshape_w_606_3486_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573120,
      .offset_end = 4573121,
      .offset_limit = 4573192,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_447_gemm_151_0_conv_607_3488_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568912,
      .offset_end = 4568916,
      .offset_limit = 4568984,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_447_gemm_151_0_conv_607_3488_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573136,
      .offset_end = 4573137,
      .offset_limit = 4573208,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_448_mul_sub2__3490_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566304,
      .offset_end = 4566308,
      .offset_limit = 4566376,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_448_mul_sub2__3490_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570528,
      .offset_end = 4570529,
      .offset_limit = 4570600,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Softmax_451_3492_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566320,
      .offset_end = 4566324,
      .offset_limit = 4566392,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Softmax_451_3492_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570544,
      .offset_end = 4570545,
      .offset_limit = 4570616,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2797_3494_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567152,
      .offset_end = 4567156,
      .offset_limit = 4567224,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2797_3494_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571376,
      .offset_end = 4571377,
      .offset_limit = 4571448,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_452_gemm_187_3_reshape_w_655_3496_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567168,
      .offset_end = 4567172,
      .offset_limit = 4567240,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_452_gemm_187_3_reshape_w_655_3496_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571392,
      .offset_end = 4571393,
      .offset_limit = 4571464,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_452_gemm_187_3_conv_656_3498_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567184,
      .offset_end = 4567188,
      .offset_limit = 4567256,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_452_gemm_187_3_conv_656_3498_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571408,
      .offset_end = 4571409,
      .offset_limit = 4571480,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2799_3500_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567728,
      .offset_end = 4567732,
      .offset_limit = 4567800,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2799_3500_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571952,
      .offset_end = 4571953,
      .offset_limit = 4572024,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_452_gemm_175_0_reshape_w_634_3502_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567744,
      .offset_end = 4567748,
      .offset_limit = 4567816,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_452_gemm_175_0_reshape_w_634_3502_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571968,
      .offset_end = 4571969,
      .offset_limit = 4572040,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_452_gemm_175_0_conv_635_3504_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567760,
      .offset_end = 4567764,
      .offset_limit = 4567832,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_452_gemm_175_0_conv_635_3504_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571984,
      .offset_end = 4571985,
      .offset_limit = 4572056,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2801_3506_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567776,
      .offset_end = 4567780,
      .offset_limit = 4567848,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2801_3506_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572000,
      .offset_end = 4572001,
      .offset_limit = 4572072,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_452_gemm_179_1_reshape_w_641_3508_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567792,
      .offset_end = 4567796,
      .offset_limit = 4567864,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_452_gemm_179_1_reshape_w_641_3508_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572016,
      .offset_end = 4572017,
      .offset_limit = 4572088,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_452_gemm_179_1_conv_642_3510_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567808,
      .offset_end = 4567812,
      .offset_limit = 4567880,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_452_gemm_179_1_conv_642_3510_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572032,
      .offset_end = 4572033,
      .offset_limit = 4572104,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2803_3512_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567824,
      .offset_end = 4567828,
      .offset_limit = 4567896,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2803_3512_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572048,
      .offset_end = 4572049,
      .offset_limit = 4572120,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_452_gemm_183_2_reshape_w_648_3514_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567840,
      .offset_end = 4567844,
      .offset_limit = 4567912,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_452_gemm_183_2_reshape_w_648_3514_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572064,
      .offset_end = 4572065,
      .offset_limit = 4572136,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_452_gemm_183_2_conv_649_3516_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567856,
      .offset_end = 4567860,
      .offset_limit = 4567928,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_452_gemm_183_2_conv_649_3516_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572080,
      .offset_end = 4572081,
      .offset_limit = 4572152,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_474_3520_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569408,
      .offset_end = 4569412,
      .offset_limit = 4569480,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_474_3520_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573632,
      .offset_end = 4573633,
      .offset_limit = 4573704,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2834_3522_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569712,
      .offset_end = 4569716,
      .offset_limit = 4569784,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2834_3522_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573936,
      .offset_end = 4573937,
      .offset_limit = 4574008,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2833_3524_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569696,
      .offset_end = 4569700,
      .offset_limit = 4569768,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2833_3524_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573920,
      .offset_end = 4573921,
      .offset_limit = 4573992,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2833_3526_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565952,
      .offset_end = 4565956,
      .offset_limit = 4566024,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2833_3526_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570176,
      .offset_end = 4570177,
      .offset_limit = 4570248,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_476_param1_3528_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565968,
      .offset_end = 4565972,
      .offset_limit = 4566040,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_476_param1_3528_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570192,
      .offset_end = 4570193,
      .offset_limit = 4570264,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_476_3530_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4565984,
      .offset_end = 4565988,
      .offset_limit = 4566056,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_476_3530_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570208,
      .offset_end = 4570209,
      .offset_limit = 4570280,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_482_param0_3533_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566720,
      .offset_end = 4566724,
      .offset_limit = 4566792,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_482_param0_3533_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570944,
      .offset_end = 4570945,
      .offset_limit = 4571016,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_479_mul_sub2__3535_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566736,
      .offset_end = 4566740,
      .offset_limit = 4566808,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_479_mul_sub2__3535_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570960,
      .offset_end = 4570961,
      .offset_limit = 4571032,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_482_3537_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566752,
      .offset_end = 4566756,
      .offset_limit = 4566824,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_482_3537_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570976,
      .offset_end = 4570977,
      .offset_limit = 4571048,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_518_3541_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569424,
      .offset_end = 4569428,
      .offset_limit = 4569496,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_518_3541_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573648,
      .offset_end = 4573649,
      .offset_limit = 4573720,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2884_3543_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569744,
      .offset_end = 4569748,
      .offset_limit = 4569816,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2884_3543_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573968,
      .offset_end = 4573969,
      .offset_limit = 4574040,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2883_3545_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569728,
      .offset_end = 4569732,
      .offset_limit = 4569800,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2883_3545_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573952,
      .offset_end = 4573953,
      .offset_limit = 4574024,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2883_3547_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566000,
      .offset_end = 4566004,
      .offset_limit = 4566072,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2883_3547_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570224,
      .offset_end = 4570225,
      .offset_limit = 4570296,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_520_param1_3549_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566016,
      .offset_end = 4566020,
      .offset_limit = 4566088,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_520_param1_3549_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570240,
      .offset_end = 4570241,
      .offset_limit = 4570312,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_520_3551_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566032,
      .offset_end = 4566036,
      .offset_limit = 4566104,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_520_3551_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570256,
      .offset_end = 4570257,
      .offset_limit = 4570328,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_526_param0_3554_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566768,
      .offset_end = 4566772,
      .offset_limit = 4566840,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_526_param0_3554_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570992,
      .offset_end = 4570993,
      .offset_limit = 4571064,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_523_mul_sub2__3556_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566784,
      .offset_end = 4566788,
      .offset_limit = 4566856,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_523_mul_sub2__3556_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571008,
      .offset_end = 4571009,
      .offset_limit = 4571080,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_526_3558_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566800,
      .offset_end = 4566804,
      .offset_limit = 4566872,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_526_3558_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571024,
      .offset_end = 4571025,
      .offset_limit = 4571096,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2921_3560_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568352,
      .offset_end = 4568356,
      .offset_limit = 4568424,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2921_3560_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572576,
      .offset_end = 4572577,
      .offset_limit = 4572648,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_562_gemm_207_2_reshape_w_718_3562_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568368,
      .offset_end = 4568372,
      .offset_limit = 4568440,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_562_gemm_207_2_reshape_w_718_3562_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572592,
      .offset_end = 4572593,
      .offset_limit = 4572664,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_562_gemm_207_2_conv_719_3564_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568384,
      .offset_end = 4568388,
      .offset_limit = 4568456,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_562_gemm_207_2_conv_719_3564_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572608,
      .offset_end = 4572609,
      .offset_limit = 4572680,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2922_3566_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569024,
      .offset_end = 4569028,
      .offset_limit = 4569096,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2922_3566_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573248,
      .offset_end = 4573249,
      .offset_limit = 4573320,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_562_gemm_199_0_reshape_w_704_3568_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569040,
      .offset_end = 4569044,
      .offset_limit = 4569112,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_562_gemm_199_0_reshape_w_704_3568_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573264,
      .offset_end = 4573265,
      .offset_limit = 4573336,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_562_gemm_199_0_conv_705_3570_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569056,
      .offset_end = 4569060,
      .offset_limit = 4569128,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_562_gemm_199_0_conv_705_3570_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573280,
      .offset_end = 4573281,
      .offset_limit = 4573352,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2923_3572_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569120,
      .offset_end = 4569124,
      .offset_limit = 4569192,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2923_3572_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573344,
      .offset_end = 4573345,
      .offset_limit = 4573416,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_562_gemm_211_3_reshape_w_725_3574_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569136,
      .offset_end = 4569140,
      .offset_limit = 4569208,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_562_gemm_211_3_reshape_w_725_3574_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573360,
      .offset_end = 4573361,
      .offset_limit = 4573432,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_562_gemm_211_3_conv_726_3576_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569152,
      .offset_end = 4569156,
      .offset_limit = 4569224,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_562_gemm_211_3_conv_726_3576_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573376,
      .offset_end = 4573377,
      .offset_limit = 4573448,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2924_3578_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569072,
      .offset_end = 4569076,
      .offset_limit = 4569144,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2924_3578_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573296,
      .offset_end = 4573297,
      .offset_limit = 4573368,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_562_gemm_203_1_reshape_w_711_3580_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569088,
      .offset_end = 4569092,
      .offset_limit = 4569160,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_562_gemm_203_1_reshape_w_711_3580_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573312,
      .offset_end = 4573313,
      .offset_limit = 4573384,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_562_gemm_203_1_conv_712_3582_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569104,
      .offset_end = 4569108,
      .offset_limit = 4569176,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_562_gemm_203_1_conv_712_3582_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573328,
      .offset_end = 4573329,
      .offset_limit = 4573400,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_563_mul_sub2__3584_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566336,
      .offset_end = 4566340,
      .offset_limit = 4566408,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_563_mul_sub2__3584_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570560,
      .offset_end = 4570561,
      .offset_limit = 4570632,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Softmax_566_3586_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566352,
      .offset_end = 4566356,
      .offset_limit = 4566424,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Softmax_566_3586_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570576,
      .offset_end = 4570577,
      .offset_limit = 4570648,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2936_3588_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567200,
      .offset_end = 4567204,
      .offset_limit = 4567272,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2936_3588_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571424,
      .offset_end = 4571425,
      .offset_limit = 4571496,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_567_gemm_235_3_reshape_w_753_3590_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567216,
      .offset_end = 4567220,
      .offset_limit = 4567288,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_567_gemm_235_3_reshape_w_753_3590_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571440,
      .offset_end = 4571441,
      .offset_limit = 4571512,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_567_gemm_235_3_conv_754_3592_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567232,
      .offset_end = 4567236,
      .offset_limit = 4567304,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_567_gemm_235_3_conv_754_3592_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571456,
      .offset_end = 4571457,
      .offset_limit = 4571528,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2938_3594_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567872,
      .offset_end = 4567876,
      .offset_limit = 4567944,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2938_3594_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572096,
      .offset_end = 4572097,
      .offset_limit = 4572168,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_567_gemm_223_0_reshape_w_732_3596_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567888,
      .offset_end = 4567892,
      .offset_limit = 4567960,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_567_gemm_223_0_reshape_w_732_3596_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572112,
      .offset_end = 4572113,
      .offset_limit = 4572184,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_567_gemm_223_0_conv_733_3598_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567904,
      .offset_end = 4567908,
      .offset_limit = 4567976,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_567_gemm_223_0_conv_733_3598_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572128,
      .offset_end = 4572129,
      .offset_limit = 4572200,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2940_3600_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567920,
      .offset_end = 4567924,
      .offset_limit = 4567992,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2940_3600_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572144,
      .offset_end = 4572145,
      .offset_limit = 4572216,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_567_gemm_227_1_reshape_w_739_3602_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567936,
      .offset_end = 4567940,
      .offset_limit = 4568008,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_567_gemm_227_1_reshape_w_739_3602_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572160,
      .offset_end = 4572161,
      .offset_limit = 4572232,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_567_gemm_227_1_conv_740_3604_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567952,
      .offset_end = 4567956,
      .offset_limit = 4568024,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_567_gemm_227_1_conv_740_3604_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572176,
      .offset_end = 4572177,
      .offset_limit = 4572248,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2942_3606_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567968,
      .offset_end = 4567972,
      .offset_limit = 4568040,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id2942_3606_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572192,
      .offset_end = 4572193,
      .offset_limit = 4572264,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_567_gemm_231_2_reshape_w_746_3608_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567984,
      .offset_end = 4567988,
      .offset_limit = 4568056,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_567_gemm_231_2_reshape_w_746_3608_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572208,
      .offset_end = 4572209,
      .offset_limit = 4572280,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_567_gemm_231_2_conv_747_3610_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568000,
      .offset_end = 4568004,
      .offset_limit = 4568072,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_567_gemm_231_2_conv_747_3610_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572224,
      .offset_end = 4572225,
      .offset_limit = 4572296,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_589_3614_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569440,
      .offset_end = 4569444,
      .offset_limit = 4569512,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_589_3614_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573664,
      .offset_end = 4573665,
      .offset_limit = 4573736,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2973_3616_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569776,
      .offset_end = 4569780,
      .offset_limit = 4569848,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2973_3616_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4574000,
      .offset_end = 4574001,
      .offset_limit = 4574072,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2972_3618_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569760,
      .offset_end = 4569764,
      .offset_limit = 4569832,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2972_3618_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573984,
      .offset_end = 4573985,
      .offset_limit = 4574056,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2972_3620_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566048,
      .offset_end = 4566052,
      .offset_limit = 4566120,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id2972_3620_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570272,
      .offset_end = 4570273,
      .offset_limit = 4570344,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_591_param1_3622_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566064,
      .offset_end = 4566068,
      .offset_limit = 4566136,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_591_param1_3622_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570288,
      .offset_end = 4570289,
      .offset_limit = 4570360,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_591_3624_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566080,
      .offset_end = 4566084,
      .offset_limit = 4566152,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_591_3624_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570304,
      .offset_end = 4570305,
      .offset_limit = 4570376,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_597_param0_3627_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566816,
      .offset_end = 4566820,
      .offset_limit = 4566888,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_597_param0_3627_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571040,
      .offset_end = 4571041,
      .offset_limit = 4571112,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_594_mul_sub2__3629_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566832,
      .offset_end = 4566836,
      .offset_limit = 4566904,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_594_mul_sub2__3629_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571056,
      .offset_end = 4571057,
      .offset_limit = 4571128,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_597_3631_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566848,
      .offset_end = 4566852,
      .offset_limit = 4566920,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_597_3631_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571072,
      .offset_end = 4571073,
      .offset_limit = 4571144,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_633_3635_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569456,
      .offset_end = 4569460,
      .offset_limit = 4569528,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_633_3635_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573680,
      .offset_end = 4573681,
      .offset_limit = 4573752,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3023_3637_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569808,
      .offset_end = 4569812,
      .offset_limit = 4569880,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3023_3637_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4574032,
      .offset_end = 4574033,
      .offset_limit = 4574104,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3022_3639_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569792,
      .offset_end = 4569796,
      .offset_limit = 4569864,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3022_3639_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4574016,
      .offset_end = 4574017,
      .offset_limit = 4574088,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3022_3641_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566096,
      .offset_end = 4566100,
      .offset_limit = 4566168,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3022_3641_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570320,
      .offset_end = 4570321,
      .offset_limit = 4570392,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_635_param1_3643_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566112,
      .offset_end = 4566116,
      .offset_limit = 4566184,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_635_param1_3643_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570336,
      .offset_end = 4570337,
      .offset_limit = 4570408,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_635_3645_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566128,
      .offset_end = 4566132,
      .offset_limit = 4566200,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_635_3645_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570352,
      .offset_end = 4570353,
      .offset_limit = 4570424,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_641_param0_3648_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566864,
      .offset_end = 4566868,
      .offset_limit = 4566936,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_641_param0_3648_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571088,
      .offset_end = 4571089,
      .offset_limit = 4571160,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_638_mul_sub2__3650_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566880,
      .offset_end = 4566884,
      .offset_limit = 4566952,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_638_mul_sub2__3650_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571104,
      .offset_end = 4571105,
      .offset_limit = 4571176,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_641_3652_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566896,
      .offset_end = 4566900,
      .offset_limit = 4566968,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_641_3652_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571120,
      .offset_end = 4571121,
      .offset_limit = 4571192,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id3060_3654_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568400,
      .offset_end = 4568404,
      .offset_limit = 4568472,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id3060_3654_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572624,
      .offset_end = 4572625,
      .offset_limit = 4572696,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_677_gemm_259_3_reshape_w_823_3656_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568416,
      .offset_end = 4568420,
      .offset_limit = 4568488,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_677_gemm_259_3_reshape_w_823_3656_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572640,
      .offset_end = 4572641,
      .offset_limit = 4572712,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_677_gemm_259_3_conv_824_3658_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568432,
      .offset_end = 4568436,
      .offset_limit = 4568504,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_677_gemm_259_3_conv_824_3658_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572656,
      .offset_end = 4572657,
      .offset_limit = 4572728,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id3061_3660_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569168,
      .offset_end = 4569172,
      .offset_limit = 4569240,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id3061_3660_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573392,
      .offset_end = 4573393,
      .offset_limit = 4573464,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_677_gemm_247_0_reshape_w_802_3662_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569184,
      .offset_end = 4569188,
      .offset_limit = 4569256,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_677_gemm_247_0_reshape_w_802_3662_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573408,
      .offset_end = 4573409,
      .offset_limit = 4573480,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_677_gemm_247_0_conv_803_3664_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569200,
      .offset_end = 4569204,
      .offset_limit = 4569272,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_677_gemm_247_0_conv_803_3664_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573424,
      .offset_end = 4573425,
      .offset_limit = 4573496,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id3062_3666_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569216,
      .offset_end = 4569220,
      .offset_limit = 4569288,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id3062_3666_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573440,
      .offset_end = 4573441,
      .offset_limit = 4573512,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_677_gemm_251_1_reshape_w_809_3668_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569232,
      .offset_end = 4569236,
      .offset_limit = 4569304,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_677_gemm_251_1_reshape_w_809_3668_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573456,
      .offset_end = 4573457,
      .offset_limit = 4573528,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_677_gemm_251_1_conv_810_3670_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569248,
      .offset_end = 4569252,
      .offset_limit = 4569320,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_677_gemm_251_1_conv_810_3670_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573472,
      .offset_end = 4573473,
      .offset_limit = 4573544,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id3063_3672_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569264,
      .offset_end = 4569268,
      .offset_limit = 4569336,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id3063_3672_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573488,
      .offset_end = 4573489,
      .offset_limit = 4573560,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_677_gemm_255_2_reshape_w_816_3674_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569280,
      .offset_end = 4569284,
      .offset_limit = 4569352,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_677_gemm_255_2_reshape_w_816_3674_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573504,
      .offset_end = 4573505,
      .offset_limit = 4573576,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_677_gemm_255_2_conv_817_3676_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569296,
      .offset_end = 4569300,
      .offset_limit = 4569368,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_677_gemm_255_2_conv_817_3676_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573520,
      .offset_end = 4573521,
      .offset_limit = 4573592,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_678_mul_sub2__3678_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566368,
      .offset_end = 4566372,
      .offset_limit = 4566440,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_678_mul_sub2__3678_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570592,
      .offset_end = 4570593,
      .offset_limit = 4570664,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Softmax_681_3680_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566384,
      .offset_end = 4566388,
      .offset_limit = 4566456,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Softmax_681_3680_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570608,
      .offset_end = 4570609,
      .offset_limit = 4570680,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id3075_3682_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567248,
      .offset_end = 4567252,
      .offset_limit = 4567320,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id3075_3682_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571472,
      .offset_end = 4571473,
      .offset_limit = 4571544,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_682_gemm_279_2_reshape_w_844_3684_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567264,
      .offset_end = 4567268,
      .offset_limit = 4567336,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_682_gemm_279_2_reshape_w_844_3684_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571488,
      .offset_end = 4571489,
      .offset_limit = 4571560,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_682_gemm_279_2_conv_845_3686_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4567280,
      .offset_end = 4567284,
      .offset_limit = 4567352,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_682_gemm_279_2_conv_845_3686_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571504,
      .offset_end = 4571505,
      .offset_limit = 4571576,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id3077_3688_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568112,
      .offset_end = 4568116,
      .offset_limit = 4568184,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id3077_3688_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572336,
      .offset_end = 4572337,
      .offset_limit = 4572408,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_682_gemm_283_3_reshape_w_851_3690_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568128,
      .offset_end = 4568132,
      .offset_limit = 4568200,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_682_gemm_283_3_reshape_w_851_3690_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572352,
      .offset_end = 4572353,
      .offset_limit = 4572424,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_682_gemm_283_3_conv_852_3692_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568144,
      .offset_end = 4568148,
      .offset_limit = 4568216,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_682_gemm_283_3_conv_852_3692_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572368,
      .offset_end = 4572369,
      .offset_limit = 4572440,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id3079_3694_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568016,
      .offset_end = 4568020,
      .offset_limit = 4568088,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id3079_3694_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572240,
      .offset_end = 4572241,
      .offset_limit = 4572312,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_682_gemm_271_0_reshape_w_830_3696_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568032,
      .offset_end = 4568036,
      .offset_limit = 4568104,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_682_gemm_271_0_reshape_w_830_3696_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572256,
      .offset_end = 4572257,
      .offset_limit = 4572328,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_682_gemm_271_0_conv_831_3698_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568048,
      .offset_end = 4568052,
      .offset_limit = 4568120,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_682_gemm_271_0_conv_831_3698_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572272,
      .offset_end = 4572273,
      .offset_limit = 4572344,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id3081_3700_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568064,
      .offset_end = 4568068,
      .offset_limit = 4568136,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Identity_inserted_id3081_3700_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572288,
      .offset_end = 4572289,
      .offset_limit = 4572360,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_682_gemm_275_1_reshape_w_837_3702_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568080,
      .offset_end = 4568084,
      .offset_limit = 4568152,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_682_gemm_275_1_reshape_w_837_3702_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572304,
      .offset_end = 4572305,
      .offset_limit = 4572376,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_682_gemm_275_1_conv_838_3704_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4568096,
      .offset_end = 4568100,
      .offset_limit = 4568168,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Gemm_682_gemm_275_1_conv_838_3704_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4572320,
      .offset_end = 4572321,
      .offset_limit = 4572392,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_704_3708_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569472,
      .offset_end = 4569476,
      .offset_limit = 4569544,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_704_3708_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573696,
      .offset_end = 4573697,
      .offset_limit = 4573768,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3112_3710_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569840,
      .offset_end = 4569844,
      .offset_limit = 4569912,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3112_3710_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4574064,
      .offset_end = 4574065,
      .offset_limit = 4574136,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3111_3712_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569824,
      .offset_end = 4569828,
      .offset_limit = 4569896,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3111_3712_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4574048,
      .offset_end = 4574049,
      .offset_limit = 4574120,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3111_3714_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566144,
      .offset_end = 4566148,
      .offset_limit = 4566216,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3111_3714_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570368,
      .offset_end = 4570369,
      .offset_limit = 4570440,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_706_param1_3716_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566160,
      .offset_end = 4566164,
      .offset_limit = 4566232,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_706_param1_3716_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570384,
      .offset_end = 4570385,
      .offset_limit = 4570456,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_706_3718_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566176,
      .offset_end = 4566180,
      .offset_limit = 4566248,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_706_3718_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570400,
      .offset_end = 4570401,
      .offset_limit = 4570472,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_712_param0_3721_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566912,
      .offset_end = 4566916,
      .offset_limit = 4566984,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_712_param0_3721_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571136,
      .offset_end = 4571137,
      .offset_limit = 4571208,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_709_mul_sub2__3723_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566928,
      .offset_end = 4566932,
      .offset_limit = 4567000,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_709_mul_sub2__3723_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571152,
      .offset_end = 4571153,
      .offset_limit = 4571224,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_712_3725_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566944,
      .offset_end = 4566948,
      .offset_limit = 4567016,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_712_3725_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571168,
      .offset_end = 4571169,
      .offset_limit = 4571240,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_748_3729_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569488,
      .offset_end = 4569492,
      .offset_limit = 4569560,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sqrt_748_3729_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4573712,
      .offset_end = 4573713,
      .offset_limit = 4573784,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3162_3731_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569872,
      .offset_end = 4569876,
      .offset_limit = 4569944,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3162_3731_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4574096,
      .offset_end = 4574097,
      .offset_limit = 4574168,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3161_3733_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4569856,
      .offset_end = 4569860,
      .offset_limit = 4569928,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3161_3733_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4574080,
      .offset_end = 4574081,
      .offset_limit = 4574152,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3161_3735_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566192,
      .offset_end = 4566196,
      .offset_limit = 4566264,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "QuantizeLinear_inserted_id3161_3735_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570416,
      .offset_end = 4570417,
      .offset_limit = 4570488,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_750_param1_3737_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566208,
      .offset_end = 4566212,
      .offset_limit = 4566280,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_750_param1_3737_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570432,
      .offset_end = 4570433,
      .offset_limit = 4570504,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_750_3739_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566224,
      .offset_end = 4566228,
      .offset_limit = 4566296,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_750_3739_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4570448,
      .offset_end = 4570449,
      .offset_limit = 4570520,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_756_param0_3742_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566960,
      .offset_end = 4566964,
      .offset_limit = 4567032,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_756_param0_3742_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571184,
      .offset_end = 4571185,
      .offset_limit = 4571256,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_753_mul_sub2__3744_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566976,
      .offset_end = 4566980,
      .offset_limit = 4567048,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Mul_753_mul_sub2__3744_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571200,
      .offset_end = 4571201,
      .offset_limit = 4571272,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_756_3746_atonn_internal_scale",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4566992,
      .offset_end = 4566996,
      .offset_limit = 4567064,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 0,
      .Qn = 0,
      .Qunsigned = 1,
      .type = DataType_FLOAT,
      .nbits = 32,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
    {
      .name = "Sub_756_3746_atonn_internal_offset",
      .addr_base = {(unsigned char *)(0x71000000UL) /* Equivalent hex address = 0x71000000UL */},
      .offset_start = 4571216,
      .offset_end = 4571217,
      .offset_limit = 4571288,
      .is_user_allocated = 0,
      .is_param = 1,
      .epoch = 0,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_U_1,
      .mem_ndims = 1,
      .chpos = CHPos_UNDEFINED,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_FXP,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1,
    },
#endif // LL_ATON_DBG_BUFFER_INFO_EXCLUDED == 0
    {
      .name = NULL,
    }
  };

  return buff_info;
}

const LL_Buffer_InfoTypeDef *LL_ATON_Output_Buffers_Info_Default(void)
{
  static const uint32_t buff_info__shape_1_30_20000[] = { 1, 30, 20000, 1 };
  static const uint32_t buff_info__mem_shape_F_1_30_20000[] = { 1, 30, 20000 };
  static const float buff_info_Quantize_769_out_0_quant_scale[] = { 0.0702753961086273 };
  static const int16_t buff_info_Quantize_769_out_0_quant_offset[] = { 14 };
  static const LL_Buffer_InfoTypeDef buff_info[] = {
    {
      .name = "Quantize_769_out_0",
      .addr_base = {(unsigned char *)(0x34100000UL) /* Equivalent hex address = 0x34100000UL */},
      .offset_start = 600000,
      .offset_end = 1200000,
      .offset_limit = 1200064,
      .is_user_allocated = 0,
      .is_param = 0,
      .epoch = 407,
      .batch = 1,
      .mem_shape = buff_info__mem_shape_F_1_30_20000,
      .mem_ndims = 3,
      .chpos = CHPos_First,
      .Qm = 7,
      .Qn = 0,
      .Qunsigned = 0,
      .type = DataType_INT8,
      .nbits = 8,
      .ndims = 4,
      .shape = buff_info__shape_1_30_20000,
      .per_channel = 0,
      .scale = buff_info_Quantize_769_out_0_quant_scale,
      .offset = buff_info_Quantize_769_out_0_quant_offset,
    },
    {
      .name = NULL,
    }
  };

  return buff_info;
}

const LL_Buffer_InfoTypeDef *LL_ATON_Internal_Buffers_Info_Default(void)
{
  return NULL;
}

